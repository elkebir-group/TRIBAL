configfile: "config.yaml"
import pandas as pd
import sys, os
sys.path.append("../../src")

def get_clones(mouse):
    files = os.listdir(f"Mouse_{mouse}/clone_data/")
    clones = [f.replace(".csv", "") for f in files]
    return clones

def expand_input(mouse):

    return [f"Mouse_{m}/dnapars/{clone}/dnapars.log" for m in mouse for clone in get_clones(m) ]

def expand_input1(mouse, modes, fname):

    return [f"Mouse_{m}/tribal_ml/{md}/{clone}/{fname}" for md in modes for m in mouse for clone in get_clones(m) ]

def expand_input2(mouse):
    files = []
    for m in mouse:
            for c in get_clones(m):
                    files.append(f"Mouse_{m}/node_scores/{c}.csv")
    return files



rule all:
    input:
        # expand_input(mouse=[1,2,3]),
        # expand_input2(mouse=config["mice"], mode=config["mode"], alpha=config["alpha"]),
        'igphyml_likelihoods.csv',
        expand_input1(mouse=config["mice"], modes=config["mode"], fname="nwk.csv"),
        expand_input1(mouse=config["mice"], modes=config["mode"], fname="node_scores.csv"),
        expand_input2(mouse=config["mice"]),
        # expand_input1(mouse=config["mice"], modes=config["mode"], fname="igphyml_mrca_dist.csv"),

        # expand("Mouse_{mouse}/clonotypes.txt", mouse = config["mice"]),
        expand("Mouse_{mouse}/tribal_ml/{mode}/transmat.txt", mouse = config["mice"], mode=config["mode"]),
        # expand("Mouse_{mouse}/tribal_ml/{mode}/trees.rds", mouse = config["mice"], mode=config["mode"])

rule csv_to_fasta:
    input: "Mouse_{mouse}/clone_data/{clone}.csv"
    output: 
        seq= "Mouse_{mouse}/clones/{clone}/heavy.fasta",
        iso="Mouse_{mouse}/clones/{clone}/isotype.fasta",
        mapping = "Mouse_{mouse}/clones/{clone}/mapping.fasta",
    shell:
        """
        python ../../src/prep_input.py -f {input} -a {output.seq} -i {output.iso} -m {output.mapping}
        """

rule convert_phylip:
    input: "Mouse_{mouse}/clones/{clone}/heavy.fasta",
    output: "Mouse_{mouse}/clones/{clone}/heavy.phylip"
    shell:
        "seqmagick convert {input} {output}"


rule dnapars_config:
    input: "Mouse_{mouse}/clones/{clone}/heavy.phylip",
    output: "Mouse_{mouse}/dnapars/{clone}/dnapars.cfg",
    shell:
        "mkconfig {input} dnapars > {output} "


rule dnapars_run:
    input: "Mouse_{mouse}/dnapars/{clone}/dnapars.cfg",
    params: 
        direct="Mouse_{mouse}/dnapars/{clone}"
    output:  "Mouse_{mouse}/dnapars/{clone}/dnapars.log"
    shell:       
        """
        (
        cd {params.direct}
        dnapars < dnapars.cfg > dnapars.log
        )
        """

rule list_clonotypes:
    input: "Mouse_{mouse}/clones"
    output: "Mouse_{mouse}/clonotypes.txt"
    shell:
        "ls {input} > {output}"

    
rule tribal_infer:
    input: 
        clonotypes = "Mouse_{mouse}/clonotypes.txt",
        encoding = "isotype_encoding.txt",
    params:
        inpath = "./Mouse_{mouse}/clones",
        lamb = 0.75,
        max_cand = config["max_cand"],
        niter = config["niter"],
        thresh = config["threshold"],
        root = "naive",
        outpath = "./Mouse_{mouse}/tribal",
        tree_path = "./Mouse_{mouse}/dnapars",
        restarts = config["nrestarts"],
        mu = config["mu"],
        sigma = config["sigma"],
        jump_prob = config["jump_prob"],
        fasta = "heavy.fasta",
        isotypes = "isotype.fasta",
        candidates = "outtree",
    threads: 5
    output:
        transmat = "Mouse_{mouse}/tribal_ml/{mode}/transmat.txt",
        stateprobs = "Mouse_{mouse}/tribal_ml/{mode}/state_probs.txt",
        heatmap = "Mouse_{mouse}/tribal_ml/{mode}/transmat.png",
        score = "Mouse_{mouse}/tribal_ml/{mode}/fit_score.txt",

    benchmark: "Mouse_{mouse}/tribal_ml/{mode}/benchmark.log"
    log:
        std = "Mouse_{mouse}/tribal_ml/{mode}/fit.log",
        err = "Mouse_{mouse}/tribal_ml/{mode}/fit.err.log"

    shell:
        "python ../../src/tribal_ml.py -c {input.clonotypes} -p {params.inpath} --fasta {params.fasta} --isotypes {params.isotypes} "
        "-r {params.root} -e {input.encoding} -s {wildcards.mouse} --candidates {params.candidates} "
        "--niter {params.niter} -j {params.jump_prob} "
        "--thresh {params.thresh} --transmat_infer {output.transmat}  --tree_path {params.tree_path}  "
        "--state_probs {output.stateprobs} --score {output.score}  "
        "--heatmap {output.heatmap} --mode {wildcards.mode} "
        "--nworkers {threads} --restarts {params.restarts} --mu {params.mu} --sigma {params.sigma} "
        " > {log.std} 2> {log.err} "

rule tribal_refine:
    input: 
        alignment= "Mouse_{mouse}/clones/{clone}/heavy.fasta",
        isotypes = "Mouse_{mouse}/clones/{clone}/isotype.fasta",
        transmat =  "Mouse_{mouse}/tribal_ml/{mode}/transmat.txt",
        candidates ="Mouse_{mouse}/dnapars/{clone}/outtree",
        encoding = "isotype_encoding.txt",
    output: 
        forest="Mouse_{mouse}/tribal_ml/{mode}/{clone}/forest.pickle",
        tree= "Mouse_{mouse}/tribal_ml/{mode}/{clone}/tree.txt",
        seq= "Mouse_{mouse}/tribal_ml/{mode}/{clone}/inferred_seq.csv",
        fasta= "Mouse_{mouse}/tribal_ml/{mode}/{clone}/inferred_seq.fasta",
        isotypes= "Mouse_{mouse}/tribal_ml/{mode}/{clone}/isotypes.csv",
        score= "Mouse_{mouse}/tribal_ml/{mode}/{clone}/scores.csv",
        png = "Mouse_{mouse}/tribal_ml/{mode}/{clone}/tree.png",
        opts = directory("Mouse_{mouse}/tribal_ml/{mode}/{clone}/opt_trees"),
        rf_dist="Mouse_{mouse}/tribal_ml/{mode}/{clone}/best_rf_dist.csv",
        best_pickle ="Mouse_{mouse}/tribal_ml/{mode}/{clone}/best_results.pickle",
        node_degree ="Mouse_{mouse}/tribal_ml/{mode}/{clone}/parsimony_node_degree.csv",
        refine_degree ="Mouse_{mouse}/tribal_ml/{mode}/{clone}/refine_node_degree.csv",
    params:
        root = "naive",
        ntrees = config["ntrees"],
    threads: config["nworkers"]
    log: 
        run= "Mouse_{mouse}/tribal_ml/{mode}/{clone}/refine.log",
        err ="Mouse_{mouse}/tribal_ml/{mode}/{clone}/refine.err.log"  
    benchmark: "Mouse_{mouse}/tribal_ml/{mode}/{clone}/refine.benchmark.log" 
    shell:
        "nice python ../../src/tribal_tree.py "
        " -r {params.root} "
        " -a {input.alignment} "
        "-t {input.transmat} "
        "-e {input.encoding} "
        "-i {input.isotypes} "
        "--candidates {input.candidates} "
        "--sequences {output.seq} "
        "--fasta {output.fasta} "
        "--score {output.score} "
        "--iso_infer {output.isotypes} "
        "--png {output.png} "
        "--mode {wildcards.mode} "
        "--ntrees {params.ntrees} "
        "--all_optimal_sol {output.opts} "
        "--best_tree_diff {output.rf_dist} "
        "--nworkers {threads} "
        "--tree {output.tree} "
        "--pickle_best {output.best_pickle} "
        "--pars_degree {output.node_degree} "
        "--refine_degree {output.refine_degree} "
        "-o {output.forest} > {log.run} 2> {log.err} "  


rule newick_strings:
    input:    
        scores= "Mouse_{mouse}/tribal_ml/{mode}/{clone}/best_results.pickle",
        mapping =  "Mouse_{mouse}/clone_data/{clone}.csv"
    output:
        newicks = "Mouse_{mouse}/tribal_ml/{mode}/{clone}/nwk.csv"
    run:
            import utils as ut 
            import lineage_tree as lt 
            import score_class as sc 
            seq_df = pd.read_csv(input.mapping)
            rev_mapping = dict(zip(seq_df["seq_short"], seq_df["sequence_id"]))
            rev_mapping["naive"] ="Germline"


            scores  = sc.load(input.scores)
            records = []
            for score in scores:
                lin_tree = score.tree
                # lin_tree = prune_unifurcations(lin_tree)
                lin_tree.relabel(rev_mapping)
        
                records.append([lin_tree.id, lin_tree.to_newick() ])
            df = pd.DataFrame(records, columns=["id", "newick"])
            df["clone_id"] = wildcards.clone
            df.to_csv(output.newicks, index=False)


rule extract_igphyml_likelihood:
    input: 
        trees= 'trees_bymouse_ccall.rds'
    output: 
        likelihood = 'igphyml_likelihoods.csv'
    conda: "r_dowser"
    script:
        "../extract_likelihood.R"

# rule tribal_search:
#         input: 
#             alignment= "Mouse_{mouse}/clones/{clone}/heavy.fasta",
#             isotypes = "Mouse_{mouse}/clones/{clone}/isotype.fasta",
#             transmat =  "Mouse_{mouse}/tribal/{mode}/transmat.txt",
#             candidates ="Mouse_{mouse}/dnapars/{clone}/outtree",
#             encoding = "isotype_encoding.txt",
#             forest="Mouse_{mouse}/tribal/{mode}/{clone}/forest.pickle",
#         output: 
#             tree= "Mouse_{mouse}/tribal/{mode}/{clone}/search_{alpha}/tree.txt",
#             seq= "Mouse_{mouse}/tribal/{mode}/{clone}/search_{alpha}/inferred_seq.csv",
#             fasta= "Mouse_{mouse}/tribal/{mode}/{clone}/search_{alpha}/inferred_seq.fasta",
#             isotypes= "Mouse_{mouse}/tribal/{mode}/{clone}/search_{alpha}/isotypes.csv",
#             score= "Mouse_{mouse}/tribal/{mode}/{clone}/search_{alpha}/scores.csv",
#             png = "Mouse_{mouse}/tribal/{mode}/{clone}/search_{alpha}/tree.png",
#             opts = directory("Mouse_{mouse}/tribal/{mode}/{clone}/search_{alpha}/opt_trees"),
#             rf_dist="Mouse_{mouse}/tribal/{mode}/{clone}/search_{alpha}/best_rf_dist.csv",
#             best_pickle ="Mouse_{mouse}/tribal/{mode}/{clone}/search_{alpha}/best_results.pickle",

#         params:
#             timeout = config["search_timeout"],
#             root = "naive",
#             ntrees = config["ntrees"],
#             nworkers = config["nworkers"]
#         log: 
#             run= "Mouse_{mouse}/tribal/{mode}/{clone}/search_{alpha}/search.log",
#             err ="Mouse_{mouse}/tribal/{mode}/{clone}/search_{alpha}/search.err.log"  
#         benchmark: "Mouse_{mouse}/tribal/{mode}/{clone}/search_{alpha}/search.benchmark.log" 
#         shell:
#             "python ../../src/tribal_tree.py "
#             " -r {params.root} "
#             " -a {input.alignment} "
#             "-t {input.transmat} "
#             "-e {input.encoding} "
#             "-i {input.isotypes} "
#             "-l {input.forest} "
#             "--forest "
#             "--alpha {wildcards.alpha} "
#             "--sequences {output.seq} "
#             "--fasta {output.fasta} "
#             "--score {output.score} "
#             "--iso_infer {output.isotypes} "
#             "--png {output.png} "
#             "--mode search "
#             "--ntrees {params.ntrees} "
#             "--all_optimal_sol {output.opts} "
#             "--best_tree_diff {output.rf_dist} "
#             "--nworkers {params.nworkers} "
#             "--tree {output.tree} "
#             "--pickle_best {output.best_pickle} "
#             "--timeout {params.timeout}  > {log.run} 2> {log.err} "  

    

# rule compare_trees:
#     input: 
#         best_pickle ="Mouse_{mouse}/tribal_ml/{mode}/{clone}/best_results.pickle",
#         mapping = "Mouse_{mouse}/clones/{clone}/mapping.fasta",
#         igphyml_tree =  "igphyml_trees/Mouse_{mouse}/{clone}.tree.csv",
#         sequences =  "igphyml_trees/Mouse_{mouse}/{clone}.sequence.csv",
#         annot =  "igphyml_trees/Mouse_{mouse}/{clone}.annotations.csv",
#         isotypes = "igphyml_trees/Mouse_{mouse}/{clone}.isotypes.csv",
#         transmat =  "Mouse_{mouse}/tribal_ml/{mode}/transmat.txt",
#         encoding = "isotype_encoding.txt",
#     params:
#            png =  "igphyml_trees/Mouse_{mouse}/{clone}.tree.png"
#     output:
#         mrca_dist ="Mouse_{mouse}/tribal_ml/{mode}/{clone}/igphyml_mrca_dist.csv",
#         scores ="Mouse_{mouse}/tribal_ml/{mode}/{clone}/ighyml_scores.csv",
#         pickle  ="Mouse_{mouse}/tribal_ml/{mode}/{clone}/ighyml.score.pickle",
#     log:"Mouse_{mouse}/tribal_ml/{mode}/{clone}/igphyml_mrca_dist.err.log"
#     shell:
#         "python ../../src/compare_trees.py "
#         "-p {input.best_pickle} "
#         "-m {input.mapping} "
#         "-i {input.isotypes} "
#         "-a {input.annot} "
#         "-e {input.encoding} "
#         "--alpha 0.9 "
#         "--transmat {input.transmat} "
#         "-s {input.sequences} "
#         "-t {input.igphyml_tree} "
#         "-T {params.png} "
#         "--pickle-score {output.pickle} "
#         "--scores {output.scores} "
#         "--collapse "
#         "-o {output.mrca_dist} 2> {log} "



rule compute_igphyml_likelihoods:
    input:      
        clones= "clone_input.rds",
    output:
        outtrees = "Mouse_{mouse}/tribal_ml/{mode}/trees.rds",
        likelihoods = "Mouse_{mouse}/tribal_ml/{mode}/likelihoods.csv"
    conda: "r_dowser"
    params:
        nproc = 5,
        nmin = 5
    script: 
        "compute_igphyml_likelihood.R"

rule igphyml_node_scores:
    input: 
        igphyml_tree =  "igphyml_trees/Mouse_{mouse}/{clone}.tree.csv",
        annot =  "igphyml_trees/Mouse_{mouse}/{clone}.annotations.csv",
        seq =  "igphyml_trees/Mouse_{mouse}/{clone}.sequence.csv",
        isotypes = "igphyml_trees/Mouse_{mouse}/{clone}.isotypes.csv",
        encoding = "isotype_encoding.txt",
    output:
        pickle  ="igphyml_trees/Mouse_{mouse}/{clone}.pickle",
        scores ="Mouse_{mouse}/node_scores/{clone}.csv",
    run:
        import lineage_tree as lt 
        import networkx as nx 
        import utils as ut 
        seq = ut.read_dict(input.seq)

        seq  = {key: list(value.strip()) for key, value in seq.items()}
        tree =nx.DiGraph()
        edges = ut.read_edge_list(input.igphyml_tree)
        tree.add_edges_from(edges)
        root = "Germline_Inferred"
        ann = ut.read_dict(input.annot)
        iso = ut.read_dict(input.isotypes)
        lintree = lt.LineageTree(tree, root)
        lintree.root_outgroup("Germline")
        lintree.pickle_tree(output.pickle)
    
        while True:
            prenodes =len(lintree.T.nodes)
    
            lintree.collapse(seq,ignore=["Germline_Inferred"])
            postnodes =len(lintree.T.nodes)
            if prenodes ==postnodes:
                break
        isotypes, rev_encoding = ut.recode_isotypes(input.encoding,iso )
        isotypes["Germline"] =0
        lintree.pickle_tree(output.pickle)
        degree_dict = lintree.get_node_degrees()
        avg_entropy, clade_entropy = lintree.avg_entropy(isotypes)
        avg_annot, ant_entropy = lintree.avg_entropy(ann)
        deg_series = pd.Series(degree_dict, name="degree").rename_axis("node")
        ent_series = pd.Series(clade_entropy, name="entropy").rename_axis("node")
        ant_series = pd.Series(ant_entropy, name="annot_entropy").rename_axis("node")
        merged_series = pd.concat([deg_series, ent_series, ant_series], axis=1)
        merged_series["tree"] = 0
        merged_series.to_csv(output.scores)






rule compute_node_scores:
    input: 
        forest ="Mouse_{mouse}/tribal_ml/{mode}/{clone}/best_results.pickle",
        annot = "igphyml_trees/Mouse_{mouse}/{clone}.annotations.csv",
        mapping =  "Mouse_{mouse}/clone_data/{clone}.csv"
    output:   
        node_scores ="Mouse_{mouse}/tribal_ml/{mode}/{clone}/node_scores.csv",
    run:
        import score_class as sc 
        scores = sc.load(input.forest)
        mapping = pd.read_csv(input.mapping)
        annot = pd.read_csv(input.annot, names=["sequence_id","annot"])
        annot_df = pd.merge(mapping, annot, how="inner", on="sequence_id")
        annot_dict = dict(zip(annot_df["seq_short"], annot_df["annot"]))
        merged_list = []
        for first in scores:
            lin_tree= first.tree 
            tree_id = lin_tree.id 
            degree_dict = lin_tree.get_node_degrees()
            avg_entropy, clade_entropy = lin_tree.avg_entropy(first.isotypes)
            avg_annot, ant_entropy = lin_tree.avg_entropy(annot_dict)
            deg_series = pd.Series(degree_dict, name="degree").rename_axis("node")
            ent_series = pd.Series(clade_entropy, name="entropy").rename_axis("node")
            ant_series = pd.Series(ant_entropy, name="annot_entropy").rename_axis("node")
            merged_series = pd.concat([deg_series, ent_series, ant_series], axis=1)
            merged_series["tree"] = tree_id
            merged_list.append(merged_series)
        merged_df = pd.concat(merged_list, axis=0)
        merged_df.to_csv(output.node_scores)

# rule compare_trees_bifurcating:
#     input: 
#         best_pickle ="Mouse_{mouse}/tribal/{mode}/{clone}/search_{alpha}/best_results.pickle",
#         mapping = "Mouse_{mouse}/clones/{clone}/mapping.fasta",
#         igphyml_tree =  "igphyml_trees/Mouse_{mouse}/{clone}.tree.csv",
#         sequences =  "igphyml_trees/Mouse_{mouse}/{clone}.sequence.csv",
#         annot =  "igphyml_trees/Mouse_{mouse}/{clone}.annotations.csv",
#         isotypes = "igphyml_trees/Mouse_{mouse}/{clone}.isotypes.csv",
#         transmat =  "Mouse_{mouse}/tribal/{mode}/transmat.txt",
#         encoding = "isotype_encoding.txt",
#     output:
#         mrca_dist ="Mouse_{mouse}/tribal/{mode}/{clone}/search_{alpha}/igphyml_mrca_dist_bifurcating.csv",
#         scores ="Mouse_{mouse}/tribal/{mode}/{clone}/search_{alpha}/ighyml_scores_bifurcating.csv",
#         pickle  ="Mouse_{mouse}/tribal/{mode}/{clone}/search_{alpha}/ighyml.score_bifurcating.pickle",
#     log:"Mouse_{mouse}/tribal/{mode}/{clone}/search_{alpha}/igphyml_mrca_dist_bifurcating.err.log"
#     shell:
#         "python ../../src/compare_trees.py "
#         "-p {input.best_pickle} "
#         "-m {input.mapping} "
#         "-i {input.isotypes} "
#         "-a {input.annot} "
#         "-e {input.encoding} "
#         "--alpha {wildcards.alpha} "
#         "--transmat {input.transmat} "
#         "-s {input.sequences} "
#         "-t {input.igphyml_tree} "
#         "--pickle-score {output.pickle} "
#         "--scores {output.scores} "
#         "-o {output.mrca_dist} 2> {log} "