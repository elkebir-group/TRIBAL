{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About","text":""},{"location":"#tribal","title":"TRIBAL","text":"<p>TRIBAL (TRee Inference of B cell clonAl Lineages) is a method to infer B cell lineage trees from single-cell RNA sequencing data. TRIBAL trees jointly model the evolutionary  processes of somatic hypermutation and class switch recombination. </p> <p>The input to TRIBAL is a multiple sequence alignment for each of the predetermined clonotypes aligned to the germline sequence and the isotype of each sequenced B cell.  The output is forest of B cell lineage trees, one for each clonotype, with nodes labeled by BCR sequences (concatenated heavy and light chain) and the isotype of each B cell, as well as an isotype transition probability matrix. </p>"},{"location":"#contact","title":"Contact","text":"<p>For help and questions please contact the El-Kebir Lab.</p>"},{"location":"#dependencies","title":"Dependencies","text":"<p>Depends: dnapars, mafft, glpk Imports: networkx, pyomo, numpy, pandas, ete3, Bio  </p>"},{"location":"#authors","title":"Authors","text":"<p>Leah L. Weber Derek Reiman Mrinomy S. Roddur  Yuanyuan Qi Mohammed El-Kebir Aly A. Khan </p>"},{"location":"#citing","title":"Citing","text":"<p>To cite TRIBAL in publications, please use</p> <p>Weber, L. L., Reiman, D., Roddur, M. S., Qi, Y., El-Kebir, M., &amp; Khan, A. A. TRIBAL: Tree Inference of B cell Clonal Lineages. bioRxiv. doi.org/10.1101/2023.11.27.568874.</p>"},{"location":"#license","title":"License","text":"<p>BSD-3</p>"},{"location":"license/","title":"License","text":"<p>Copyright 2024  Leah L. Weber</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ol> <li> <p>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</p> </li> <li> <p>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</p> </li> </ol> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \u201cAS IS\u201d AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"api/base_tree/","title":"BaseTree","text":"<p>Dataclass for the tree toplogy of a B cell lineage tree.</p> <p>Attributes:</p> Name Type Description <code>T</code> <code>Digraph</code> <p>a rooted tree </p> <code>root</code> <code>str</code> <p>the unique identifier of the root</p> <code>id</code> <code>(int, optional)</code> <p>the identifier of the tree</p> <code>name</code> <code>(str, optional)</code> <p>the name of the tree</p> Source code in <code>tribal/base_tree.py</code> <pre><code>@dataclass\nclass BaseTree:\n    \"\"\"Dataclass for the tree toplogy of a B cell lineage tree.\n\n    Attributes\n    ----------\n    T : nx.Digraph\n        a rooted tree \n    root : str\n        the unique identifier of the root\n    id : int, optional\n        the identifier of the tree\n    name : str, optional\n        the name of the tree\n    \"\"\"\n\n    T: nx.DiGraph\n    root: str\n    id: int = 0\n    name: str = None\n\n\n    def postorder_traversal(self) -&gt; list:\n        \"\"\"\n        Perform a postorder traversal of the tree.\n\n        Postorder traversal means visiting the children nodes first, and then the parent node.\n\n        Returns\n        -------\n        list\n            List of nodes in postorder.\n        \"\"\"\n        return list(nx.dfs_postorder_nodes(self.T, source=self.root))\n\n    def preorder_traversal(self) -&gt; list:\n        \"\"\"\n        Perform a preorder traversal of the tree.\n\n        Preorder traversal means visiting the parent node first, and then the children nodes.\n\n        Returns\n        -------\n        list\n            List of nodes in preorder.\n        \"\"\"\n        return list(nx.dfs_preorder_nodes(self.T, source=self.root))\n\n    def nodes(self):\n        \"\"\"Return the list of nodes of the tree.\"\"\"\n        return list(self.T.nodes)\n\n    def edges(self):\n        \"\"\"Return the list of edges of the tree.\"\"\"\n        return list(self.T.edges)\n\n    def parent(self, n):\n        \"\"\"Get the parent node of the given node.\n\n        Parameters\n        ----------\n        n : node\n            The node for which to find the parent.\n\n        Returns\n        -------\n        str | None\n            The parent node if it exists, otherwise None.\n        \"\"\"\n        preds = list(self.T.predecessors(n))\n        if len(preds) == 0:\n            return None\n\n        return preds[0]\n\n    def relabel(self, labels):\n        \"\"\"Relabels a tree in place.\n\n        Parameters\n        ----------\n        labels : dict\n            a dictionary with current nodes as keys and new labels as values. May include only \n            a subset of nodes.\n        \"\"\"\n        self.T = nx.relabel_nodes(self.T, labels)\n        if self.root in labels:\n            self.root = labels[self.root]\n\n    def children(self,n):\n        \"\"\"Return the set of children of a specified node `n`.\"\"\"\n        return list(self.T.neighbors(n))\n\n    def is_leaf(self, node):\n        \"\"\"Check if node is a leaf of the tree.\n\n        Parameters\n        ----------\n        node : str | int\n            a node in the lineage tree\n\n        Returns\n        -------\n        bool\n            leaf status of the specified node \n        \"\"\"\n        return self.T.out_degree(node) ==0\n\n    def get_leafs(self):\n        \"\"\"Return the leafset of the lineage tree.\"\"\"\n        return [n for n in self.T if self.is_leaf(n)]\n\n    def is_root(self, node):\n        \"\"\"Check if node is the root.\n\n        Parameters\n        ----------\n        node : str | int\n            a node in the lineage tree\n\n        Returns\n        -------\n        bool\n            indicator if the node is the root\n\n        \"\"\"\n        if type(node) == int:\n            node =str(node)\n        return node == self.root\n\n    def get_parents(self):\n        \"\"\"Obtain the parent of each node.\n\n        Returns\n        -------\n        dict\n            node as key and parent node as child. \"\" indicates no parent, i.e., the root.\n        \"\"\"\n        parents = {}\n        for n in self.T:\n            parent = self.parent(n)\n            if parent is not None:\n                parents[n] = parent\n        return parents\n\n    def set_id(self,id):\n        \"\"\"Update the id of the tree.\n\n        Parameters\n        -------\n        id : str,int\n            the new id of the tree\n        \"\"\"\n        self.id =id\n\n    def set_name(self, name):\n        \"\"\"Update the name of the tree.\n\n        Parameters\n        -------\n        name : str\n            the new id of the tree\n        \"\"\"\n        self.name= name\n\n    @staticmethod\n    def find_leaf_descendants(node, graph):\n        \"\"\"Obtain all descendants of a node in a graph that is a leaf.\n\n        Parameters\n        ----------\n        node : str, int\n        graph : nx.DiGraph\n\n        Returns\n        -------\n            the set of leaf descendants\n\n        \"\"\"\n        leaf_descendants = set()\n\n        # Helper function to traverse the graph\n        def dfs(current_node):\n            nonlocal leaf_descendants\n            # If the current node is a leaf, add it to the set\n            if graph.out_degree(current_node) == 0:\n                leaf_descendants.add(current_node)\n            else:\n                # Traverse all child nodes recursively\n                for child_node in graph.successors(current_node):\n                    dfs(child_node)\n\n        # Start the depth-first search from the specified node\n        dfs(node)\n        return leaf_descendants\n\n    def get_clade_set(self, tree):\n        \"\"\"Get the clades of the tree.\"\"\"\n        clade_set = []\n        for node in tree:\n            clade_set.append(self.find_leaf_descendants(node, tree))\n\n        return(set(map(frozenset, clade_set)))\n\n\n    def save_edges(self, fname):\n        \"\"\"Write the edge list to a file.\n\n        Parameters\n        ----------\n        fname : str\n            the file where the edge list should be saved.\n        \"\"\"\n        with open(fname, \"w+\") as file:\n            for u,v in self.T.edges:\n                file.write(f\"{u},{v}\\n\")\n\n    def get_edge_df(self):\n        \"\"\"Get the edge list as a pandas.DataFrame.\"\"\"\n        u_list =[u for u,v in self.T.edges]\n        v_list = [v for u,v in self.T.edges]\n        return DataFrame({'parent': u_list, 'child': v_list})\n</code></pre>"},{"location":"api/base_tree/#tribal.BaseTree.children","title":"<code>children(n)</code>","text":"<p>Return the set of children of a specified node <code>n</code>.</p> Source code in <code>tribal/base_tree.py</code> <pre><code>def children(self,n):\n    \"\"\"Return the set of children of a specified node `n`.\"\"\"\n    return list(self.T.neighbors(n))\n</code></pre>"},{"location":"api/base_tree/#tribal.BaseTree.edges","title":"<code>edges()</code>","text":"<p>Return the list of edges of the tree.</p> Source code in <code>tribal/base_tree.py</code> <pre><code>def edges(self):\n    \"\"\"Return the list of edges of the tree.\"\"\"\n    return list(self.T.edges)\n</code></pre>"},{"location":"api/base_tree/#tribal.BaseTree.find_leaf_descendants","title":"<code>find_leaf_descendants(node, graph)</code>  <code>staticmethod</code>","text":"<p>Obtain all descendants of a node in a graph that is a leaf.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>(str, int)</code> required <code>graph</code> <code>DiGraph</code> required <p>Returns:</p> Type Description <code>    the set of leaf descendants</code> Source code in <code>tribal/base_tree.py</code> <pre><code>@staticmethod\ndef find_leaf_descendants(node, graph):\n    \"\"\"Obtain all descendants of a node in a graph that is a leaf.\n\n    Parameters\n    ----------\n    node : str, int\n    graph : nx.DiGraph\n\n    Returns\n    -------\n        the set of leaf descendants\n\n    \"\"\"\n    leaf_descendants = set()\n\n    # Helper function to traverse the graph\n    def dfs(current_node):\n        nonlocal leaf_descendants\n        # If the current node is a leaf, add it to the set\n        if graph.out_degree(current_node) == 0:\n            leaf_descendants.add(current_node)\n        else:\n            # Traverse all child nodes recursively\n            for child_node in graph.successors(current_node):\n                dfs(child_node)\n\n    # Start the depth-first search from the specified node\n    dfs(node)\n    return leaf_descendants\n</code></pre>"},{"location":"api/base_tree/#tribal.BaseTree.get_clade_set","title":"<code>get_clade_set(tree)</code>","text":"<p>Get the clades of the tree.</p> Source code in <code>tribal/base_tree.py</code> <pre><code>def get_clade_set(self, tree):\n    \"\"\"Get the clades of the tree.\"\"\"\n    clade_set = []\n    for node in tree:\n        clade_set.append(self.find_leaf_descendants(node, tree))\n\n    return(set(map(frozenset, clade_set)))\n</code></pre>"},{"location":"api/base_tree/#tribal.BaseTree.get_edge_df","title":"<code>get_edge_df()</code>","text":"<p>Get the edge list as a pandas.DataFrame.</p> Source code in <code>tribal/base_tree.py</code> <pre><code>def get_edge_df(self):\n    \"\"\"Get the edge list as a pandas.DataFrame.\"\"\"\n    u_list =[u for u,v in self.T.edges]\n    v_list = [v for u,v in self.T.edges]\n    return DataFrame({'parent': u_list, 'child': v_list})\n</code></pre>"},{"location":"api/base_tree/#tribal.BaseTree.get_leafs","title":"<code>get_leafs()</code>","text":"<p>Return the leafset of the lineage tree.</p> Source code in <code>tribal/base_tree.py</code> <pre><code>def get_leafs(self):\n    \"\"\"Return the leafset of the lineage tree.\"\"\"\n    return [n for n in self.T if self.is_leaf(n)]\n</code></pre>"},{"location":"api/base_tree/#tribal.BaseTree.get_parents","title":"<code>get_parents()</code>","text":"<p>Obtain the parent of each node.</p> <p>Returns:</p> Type Description <code>dict</code> <p>node as key and parent node as child. \"\" indicates no parent, i.e., the root.</p> Source code in <code>tribal/base_tree.py</code> <pre><code>def get_parents(self):\n    \"\"\"Obtain the parent of each node.\n\n    Returns\n    -------\n    dict\n        node as key and parent node as child. \"\" indicates no parent, i.e., the root.\n    \"\"\"\n    parents = {}\n    for n in self.T:\n        parent = self.parent(n)\n        if parent is not None:\n            parents[n] = parent\n    return parents\n</code></pre>"},{"location":"api/base_tree/#tribal.BaseTree.is_leaf","title":"<code>is_leaf(node)</code>","text":"<p>Check if node is a leaf of the tree.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>str | int</code> <p>a node in the lineage tree</p> required <p>Returns:</p> Type Description <code>bool</code> <p>leaf status of the specified node</p> Source code in <code>tribal/base_tree.py</code> <pre><code>def is_leaf(self, node):\n    \"\"\"Check if node is a leaf of the tree.\n\n    Parameters\n    ----------\n    node : str | int\n        a node in the lineage tree\n\n    Returns\n    -------\n    bool\n        leaf status of the specified node \n    \"\"\"\n    return self.T.out_degree(node) ==0\n</code></pre>"},{"location":"api/base_tree/#tribal.BaseTree.is_root","title":"<code>is_root(node)</code>","text":"<p>Check if node is the root.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>str | int</code> <p>a node in the lineage tree</p> required <p>Returns:</p> Type Description <code>bool</code> <p>indicator if the node is the root</p> Source code in <code>tribal/base_tree.py</code> <pre><code>def is_root(self, node):\n    \"\"\"Check if node is the root.\n\n    Parameters\n    ----------\n    node : str | int\n        a node in the lineage tree\n\n    Returns\n    -------\n    bool\n        indicator if the node is the root\n\n    \"\"\"\n    if type(node) == int:\n        node =str(node)\n    return node == self.root\n</code></pre>"},{"location":"api/base_tree/#tribal.BaseTree.nodes","title":"<code>nodes()</code>","text":"<p>Return the list of nodes of the tree.</p> Source code in <code>tribal/base_tree.py</code> <pre><code>def nodes(self):\n    \"\"\"Return the list of nodes of the tree.\"\"\"\n    return list(self.T.nodes)\n</code></pre>"},{"location":"api/base_tree/#tribal.BaseTree.parent","title":"<code>parent(n)</code>","text":"<p>Get the parent node of the given node.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>node</code> <p>The node for which to find the parent.</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>The parent node if it exists, otherwise None.</p> Source code in <code>tribal/base_tree.py</code> <pre><code>def parent(self, n):\n    \"\"\"Get the parent node of the given node.\n\n    Parameters\n    ----------\n    n : node\n        The node for which to find the parent.\n\n    Returns\n    -------\n    str | None\n        The parent node if it exists, otherwise None.\n    \"\"\"\n    preds = list(self.T.predecessors(n))\n    if len(preds) == 0:\n        return None\n\n    return preds[0]\n</code></pre>"},{"location":"api/base_tree/#tribal.BaseTree.postorder_traversal","title":"<code>postorder_traversal()</code>","text":"<p>Perform a postorder traversal of the tree.</p> <p>Postorder traversal means visiting the children nodes first, and then the parent node.</p> <p>Returns:</p> Type Description <code>list</code> <p>List of nodes in postorder.</p> Source code in <code>tribal/base_tree.py</code> <pre><code>def postorder_traversal(self) -&gt; list:\n    \"\"\"\n    Perform a postorder traversal of the tree.\n\n    Postorder traversal means visiting the children nodes first, and then the parent node.\n\n    Returns\n    -------\n    list\n        List of nodes in postorder.\n    \"\"\"\n    return list(nx.dfs_postorder_nodes(self.T, source=self.root))\n</code></pre>"},{"location":"api/base_tree/#tribal.BaseTree.preorder_traversal","title":"<code>preorder_traversal()</code>","text":"<p>Perform a preorder traversal of the tree.</p> <p>Preorder traversal means visiting the parent node first, and then the children nodes.</p> <p>Returns:</p> Type Description <code>list</code> <p>List of nodes in preorder.</p> Source code in <code>tribal/base_tree.py</code> <pre><code>def preorder_traversal(self) -&gt; list:\n    \"\"\"\n    Perform a preorder traversal of the tree.\n\n    Preorder traversal means visiting the parent node first, and then the children nodes.\n\n    Returns\n    -------\n    list\n        List of nodes in preorder.\n    \"\"\"\n    return list(nx.dfs_preorder_nodes(self.T, source=self.root))\n</code></pre>"},{"location":"api/base_tree/#tribal.BaseTree.relabel","title":"<code>relabel(labels)</code>","text":"<p>Relabels a tree in place.</p> <p>Parameters:</p> Name Type Description Default <code>labels</code> <code>dict</code> <p>a dictionary with current nodes as keys and new labels as values. May include only  a subset of nodes.</p> required Source code in <code>tribal/base_tree.py</code> <pre><code>def relabel(self, labels):\n    \"\"\"Relabels a tree in place.\n\n    Parameters\n    ----------\n    labels : dict\n        a dictionary with current nodes as keys and new labels as values. May include only \n        a subset of nodes.\n    \"\"\"\n    self.T = nx.relabel_nodes(self.T, labels)\n    if self.root in labels:\n        self.root = labels[self.root]\n</code></pre>"},{"location":"api/base_tree/#tribal.BaseTree.save_edges","title":"<code>save_edges(fname)</code>","text":"<p>Write the edge list to a file.</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>str</code> <p>the file where the edge list should be saved.</p> required Source code in <code>tribal/base_tree.py</code> <pre><code>def save_edges(self, fname):\n    \"\"\"Write the edge list to a file.\n\n    Parameters\n    ----------\n    fname : str\n        the file where the edge list should be saved.\n    \"\"\"\n    with open(fname, \"w+\") as file:\n        for u,v in self.T.edges:\n            file.write(f\"{u},{v}\\n\")\n</code></pre>"},{"location":"api/base_tree/#tribal.BaseTree.set_id","title":"<code>set_id(id)</code>","text":"<p>Update the id of the tree.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>(str, int)</code> <p>the new id of the tree</p> required Source code in <code>tribal/base_tree.py</code> <pre><code>def set_id(self,id):\n    \"\"\"Update the id of the tree.\n\n    Parameters\n    -------\n    id : str,int\n        the new id of the tree\n    \"\"\"\n    self.id =id\n</code></pre>"},{"location":"api/base_tree/#tribal.BaseTree.set_name","title":"<code>set_name(name)</code>","text":"<p>Update the name of the tree.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the new id of the tree</p> required Source code in <code>tribal/base_tree.py</code> <pre><code>def set_name(self, name):\n    \"\"\"Update the name of the tree.\n\n    Parameters\n    -------\n    name : str\n        the new id of the tree\n    \"\"\"\n    self.name= name\n</code></pre>"},{"location":"api/clonotype/","title":"Clonotype","text":"<p>A class to model the clonotype input data. </p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>the label of the clonotype</p> <code>alignment</code> <code>dict</code> <p>the multiple sequence alignment for the BCR sequences</p> <code>isotypes</code> <code>dict</code> <p>the encoded isotypes of the sequenced B cells</p> <code>forest</code> <code>list</code> <p>a list of networkx.Digraphs containing the maximum parsimony forest for a  the multiple sequence alignment</p> <code>isotype_encoding</code> <code>list</code> <p>an ordered list of the labels of the isotypes. This is important because naming conventions of isotype states, i.e., IgM, M, IghM, ighm, vary across datasets.</p> Source code in <code>tribal/clonotype.py</code> <pre><code>@dataclass\nclass Clonotype:\n    \"\"\"A class to model the clonotype input data. \n\n    Attributes\n    ----------\n    id : str\n        the label of the clonotype\n    alignment : dict\n        the multiple sequence alignment for the BCR sequences\n    isotypes : dict\n        the encoded isotypes of the sequenced B cells\n    forest : list\n        a list of networkx.Digraphs containing the maximum parsimony forest for a \n        the multiple sequence alignment\n    isotype_encoding : list\n        an ordered list of the labels of the isotypes. This is important because naming\n        conventions of isotype states, i.e., IgM, M, IghM, ighm, vary across datasets.\n\n    \"\"\"\n    id: str   #id label of the clonotype\n    alignment: dict = None\n    isotypes: dict = None\n    forest: list = field(default_factory=list)\n    isotype_encoding: list = None\n\n    def generate_from_list(self, tree_list, root=None):\n        \"\"\"Populate the parsimony forst from a list of networkx digraphs.\n\n        Parameters\n        ----------\n        tree_list : list\n            a list of nx.DiGraphs containing the trees to populate the parsimony forest\n        root : str, optional\n            the root id of each B cell lineage tree\n\n        \"\"\"\n        for i,t in enumerate(tree_list):\n            if isinstance(t, BaseTree):\n                t.set_id(i)\n                self.add(t)\n            else:\n                self.add(BaseTree(t,root,i))\n\n    def add(self, tree):\n        \"\"\"Add a tree to the parsimony forest.\n        Parameters\n        ----------\n        tree : nx.DiGraph\n            a tree to add to the parsimony forest\n        \"\"\"\n        self.forest.append(tree)\n\n    def __getitem__(self, key):\n        \"\"\"Slice a tree in the parsimony forest.\"\"\"\n        return self.forest[key]\n\n    def size(self):\n        \"\"\"Return the size of the parsimony forest.\"\"\"\n        return len(self.forest)\n\n    def get_forest(self):\n        \"\"\"Return the parsimony forest.\"\"\"\n        return self.forest\n\n    def save(self, fname):\n        \"\"\"Pickle the clonotype.\n\n        Parameters\n        ----------\n        fname : str\n            the filename where the clonotype should be pickled.\n        \"\"\"\n        with open(fname, 'wb') as file:\n            pickle.dump(self, file)\n</code></pre>"},{"location":"api/clonotype/#tribal.Clonotype.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Slice a tree in the parsimony forest.</p> Source code in <code>tribal/clonotype.py</code> <pre><code>def __getitem__(self, key):\n    \"\"\"Slice a tree in the parsimony forest.\"\"\"\n    return self.forest[key]\n</code></pre>"},{"location":"api/clonotype/#tribal.Clonotype.add","title":"<code>add(tree)</code>","text":"<p>Add a tree to the parsimony forest.</p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>DiGraph</code> <p>a tree to add to the parsimony forest</p> required Source code in <code>tribal/clonotype.py</code> <pre><code>def add(self, tree):\n    \"\"\"Add a tree to the parsimony forest.\n    Parameters\n    ----------\n    tree : nx.DiGraph\n        a tree to add to the parsimony forest\n    \"\"\"\n    self.forest.append(tree)\n</code></pre>"},{"location":"api/clonotype/#tribal.Clonotype.generate_from_list","title":"<code>generate_from_list(tree_list, root=None)</code>","text":"<p>Populate the parsimony forst from a list of networkx digraphs.</p> <p>Parameters:</p> Name Type Description Default <code>tree_list</code> <code>list</code> <p>a list of nx.DiGraphs containing the trees to populate the parsimony forest</p> required <code>root</code> <code>str</code> <p>the root id of each B cell lineage tree</p> <code>None</code> Source code in <code>tribal/clonotype.py</code> <pre><code>def generate_from_list(self, tree_list, root=None):\n    \"\"\"Populate the parsimony forst from a list of networkx digraphs.\n\n    Parameters\n    ----------\n    tree_list : list\n        a list of nx.DiGraphs containing the trees to populate the parsimony forest\n    root : str, optional\n        the root id of each B cell lineage tree\n\n    \"\"\"\n    for i,t in enumerate(tree_list):\n        if isinstance(t, BaseTree):\n            t.set_id(i)\n            self.add(t)\n        else:\n            self.add(BaseTree(t,root,i))\n</code></pre>"},{"location":"api/clonotype/#tribal.Clonotype.get_forest","title":"<code>get_forest()</code>","text":"<p>Return the parsimony forest.</p> Source code in <code>tribal/clonotype.py</code> <pre><code>def get_forest(self):\n    \"\"\"Return the parsimony forest.\"\"\"\n    return self.forest\n</code></pre>"},{"location":"api/clonotype/#tribal.Clonotype.save","title":"<code>save(fname)</code>","text":"<p>Pickle the clonotype.</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>str</code> <p>the filename where the clonotype should be pickled.</p> required Source code in <code>tribal/clonotype.py</code> <pre><code>def save(self, fname):\n    \"\"\"Pickle the clonotype.\n\n    Parameters\n    ----------\n    fname : str\n        the filename where the clonotype should be pickled.\n    \"\"\"\n    with open(fname, 'wb') as file:\n        pickle.dump(self, file)\n</code></pre>"},{"location":"api/clonotype/#tribal.Clonotype.size","title":"<code>size()</code>","text":"<p>Return the size of the parsimony forest.</p> Source code in <code>tribal/clonotype.py</code> <pre><code>def size(self):\n    \"\"\"Return the size of the parsimony forest.\"\"\"\n    return len(self.forest)\n</code></pre>"},{"location":"api/lineagetree/","title":"B cell Lineage Tree","text":"<p>A class to model B cell lineage trees.</p> <p>Attributes:</p> Name Type Description <code>clonotype</code> <code>str</code> <p>The name of the clonotype.</p> <code>tree</code> <code>BaseTree</code> <p>The rooted tree topology.</p> <code>csr_obj</code> <code>float</code> <p>The current CSR likelihood of the Lineage tree (default: 0).</p> <code>isotype</code> <code>dict</code> <p>The isotype labels of the Lineage tree nodes.</p> <code>shm_obj</code> <code>float</code> <p>The current SHM Parsimony score of the Lineage tree (default: 0).</p> <code>sequences</code> <code>dict</code> <p>The BCR sequences of the Lineage tree nodes.</p> Notes <p>A B cell lineage tree is a rooted tree with nodes labeled by BCR sequences (concatenated heavy and light chain) and isotypes. The somatic hypermutation (SHM) parsimony score is the total number of base substitutions within the sequences, and  the class switch (CSR) likelihood is the likelihood of the isotype labels given an isotype transition probability matrix.</p> Source code in <code>tribal/lineage_tree.py</code> <pre><code>@dataclass\n@total_ordering\nclass LineageTree:\n    \"\"\"\n    A class to model B cell lineage trees.\n\n    Attributes\n    ----------\n    clonotype : str\n        The name of the clonotype.\n    tree : BaseTree\n        The rooted tree topology.\n    csr_obj : float \n        The current CSR likelihood of the Lineage tree (default: 0).\n    isotype : dict\n        The isotype labels of the Lineage tree nodes.\n    shm_obj : float \n        The current SHM Parsimony score of the Lineage tree (default: 0).\n    sequences : dict\n        The BCR sequences of the Lineage tree nodes.\n\n    Notes\n    -----\n    A B cell lineage tree is a rooted tree with nodes labeled by BCR sequences (concatenated heavy and light chain) and\n    isotypes. The somatic hypermutation (SHM) parsimony score is the total number of base substitutions within the sequences, and \n    the class switch (CSR) likelihood is the likelihood of the isotype labels given an isotype transition probability matrix.\n    \"\"\"\n\n    clonotype: str\n    tree: BaseTree= None\n    csr_obj: float = 0\n    isotypes: dict = field(default_factory=dict)\n    shm_obj: float = 0\n    sequences: dict = field(default_factory=dict)\n\n    def __post_init__(self):\n        \"\"\"Initialize the objective tuple and root.\"\"\"\n        self.objective = (self.shm_obj,self.csr_obj)\n        self.root = self.tree.root\n\n    def _validate_item(self, item):\n        \"\"\"Check comparison items is an instance of LineageTree.\"\"\"\n        if isinstance(item, (LineageTree)):\n            return item\n        raise TypeError(\n            f\"Score expected, item got {type(item).__name__}\"\n        )\n    def __eq__(self, __value: object) -&gt; bool:\n        \"\"\"Check if two lineage tree items have the same objective score.\"\"\"\n        item = self._validate_item(__value)\n        return self.objective ==item.objective\n\n    def __lt__(self, __value: object) -&gt; bool:\n        \"\"\"Check if a LineageTree is less than another.\"\"\"\n        item = self._validate_item(__value)\n        return self.objective &lt;item.objective\n\n    def __str__(self):\n        \"\"\"To string method.\"\"\"\n        mystr = f\"B cell lineage tree for {len(self.tree.get_leafs())} cells\"\n        mystr += f\"\\nRoot id: {self.root}\"\n        mystr += f\"# of nodes: {len(self.tree.T.nodes)}\"\n        mystr +=  f\"\\nObjective\\n----------\\nSHM: {self.shm_obj}\\nCSR: {self.csr_obj}\"\n        return mystr\n\n    def to_pickle(self, fname):\n        \"\"\"Pickle the B cell lineage tree.\n\n        Parameters\n        ----------\n        fname : str\n            the path to where the pickled object should be saved,\n        \"\"\"\n        with open(fname, 'wb') as file:\n            pickle.dump(self, file)\n\n    def _seq_len(self):\n        for _, val in self.sequences.items():\n            return len(val)\n\n    def compute_csr_likelihood(self, transmat):\n        \"\"\"Compute CSR likelihood of a lineage tree for a given isotype transition probability matrix.\n\n        Parameters\n        ----------\n        transmat : numpy.array\n            The isotype transition probability used to compute the CSR likelihood.\n\n        Returns\n        -------\n            The class switch recombination (CSR) likelihood.\n        \"\"\"\n        transmat = -np.log(transmat)\n\n        iso = self.isotypes\n        score = 0\n        try:\n            nodes = self.tree.preorder_traversal()\n            for n in nodes:\n                t = iso[n]\n                for c in self.tree.children(n):\n                    s = iso[c]\n                    score += transmat[t, s]\n        except:\n            raise ValueError(\"Invalid isotypes or tree. \\\n                             First run isotype parsimony or refinement functions.\")\n\n        self.csr_obj = score\n        return self.csr_obj\n\n\n    def get_id(self):\n        \"\"\"Get the internal id of the tree topology. Useful for mapping refined trees back the to the unrefined tree in the parsimony forest.\n\n        Returns\n        -------\n        : int\n            the internal id of the tree topology\n        \"\"\"\n        return self.tree.id\n\n    def ancestral_sequence_reconstruction(self, alignment,\n                           alphabet=(\"A\", \"C\", \"G\", \"T\",\"N\", \"-\"), \n                           cost_function=None):\n        \"\"\"Infer the ancestral BCR sequences of the internal nodes given an alignment.\n\n        Parameters\n        ----------\n        alignment : dict\n            a dictionary with leaf labels and root id as keys and the BCR sequence as value.\n\n        alphabet : tuple\n            the valid alphabet for BCR sequences, default:  (\"A\", \"C\", \"G\", \"T\",\"N\", \"-\")\n\n        cost_function : dict|None\n            the cost function for substitution of a single nucleotide base. If None, the \n            standard 0/1 cost function is used for matches and mismatches. If dictionary\n            all pairs of the elements in the alpabet should be be includes in the keys.\n\n        Examples\n        --------\n        Here is an example of how to reconstruct ancestral sequences::\n\n        ```python  \n            from tribal import clonotypes, LineageTree\n            id = \"Clonotype_1036\"\n            clonotype = clonotypes[id]\n            forest = clonotype.get_forest()\n            lt = LineageTree(id=id, tree = forest[0])\n            shm_score, sequences = lt.ancestral_sequence_reconstruction(clonotype.alignment)\n            print(lt)\n        ```\n\n        Returns\n        -------\n        : float\n            a float with the somatic hypermutation (SHM) parsimony score for the lineage tree\n\n        : dict\n            a dictionary containing the BCR sequence labels of the lineage tree\n\n        \"\"\"     \n        alignment = {k: list(alignment[k]) for k in alignment}\n        sp = SmallParsimony(self.tree, \n                            alphabet= alphabet,\n                            cost = cost_function)\n        self.shm_obj, sequences = sp.sankoff(alignment)\n        self.sequences = {key : \"\".join(value) for key, value in sequences.items()}\n\n        return self.shm_obj, self.sequences\n\n\n\n    def isotype_parsimony(self, isotype_labels:dict, transmat:np.array):\n        \"\"\"Infer the isotype of the B cell lineage tree using weighted parsimony.\n\n        Parameters\n        ----------\n        isotype_labels : dict\n            a dictionary with leaf labels and root id as keys and isotypes as values.  \n        transmat : numpy.array\n            the isotype transition probability used to compute the CSR likelihood.  \n\n        Examples\n        --------\n        Here is an example of how to infer isotypes::\n\n        ```python\n            from tribal import clonotypes, probabilities, LineageTree\n\n            id = \"Clonotype_1036\"\n            clonotype = clonotypes[id]\n            forest = clonotype.get_forest()\n            lt = LineageTree(id=id, tree = forest[0] )\n            csr_likelihood, isotypes = lt.isotype_parsimony(isotype_labels= clonotype.isotypes,\n                                                                        transmat=probabilities )\n            print(lt)\n        ```\n\n        Returns\n        -------\n        csr_obj : float\n            a float with the class switch recombination likelihood score for the lineage tree.  \n        isotypes : dict\n            a dictionary containing the isotypes of the lineage tree.  \n        \"\"\"\n        transmat = -np.log(transmat)\n        states = list(range(transmat.shape[0]))\n        sp = SmallParsimony(self.tree, alphabet=states,cost=transmat)\n        self.csr_obj, self.isotypes = sp.sankoff(isotype_labels)\n\n\n    def refinement(self, isotype_labels: Dict[str, str], transmat: np.ndarray) -&gt; Tuple[float, Dict[str, str]]:\n        \"\"\"Solves the most parsimonious tree refinement problem (MPTR).\n\n        Parameters\n        ----------\n        isotype_labels : dict\n            A dictionary with leaf labels and root id as keys and isotypes as values.\n        transmat : numpy.array\n            The isotype transition probability used to compute the CSR likelihood.\n\n        Examples\n        --------\n        Here is an example of how to refine a lineage tree:\n\n        ```python\n        from tribal import clonotypes, probabilities, LineageTree\n\n        id = \"Clonotype_1036\"\n        clonotype = clonotypes[id]\n        forest = clonotype.get_forest()\n        lt = LineageTree(id=id, tree=forest[0])\n        csr_likelihood, isotypes = lt.refinement(isotype_labels=clonotype.isotypes, transmat=probabilities)\n        print(lt)\n        ```\n\n        Returns\n        -------\n        float\n            A float with the class switch recombination likelihood score for the lineage tree.  \n\n        dict\n            A dictionary containing the isotypes of the lineage tree.  \n        \"\"\"\n        cost = -np.log(transmat)\n        cg = ConstructGraph(cost, isotype_labels, root_identifier=self.root)\n        fg = cg.build(self.tree)\n\n        st = MPTR(fg.G,\n                  self.tree.T,\n                  fg.find_terminals(),\n                  fg.iso_weights,\n                  fg.tree_to_graph,\n                  root=self.root)\n\n        self.csr_obj, tree = st.run()\n\n        tree, self.isotypes = cg.decodeTree(tree)\n        self.tree = BaseTree(tree, self.root, self.tree.id, self.tree.name)\n\n        return self.csr_obj, self.isotypes\n\n    def draw(self,\n            fname,\n            isotype_encoding=None,\n            show_legend=False,\n            show_labels=True,\n            hide_underscore=True,\n            color_encoding = None,\n            dot = False):\n        \"\"\"Visualization of the current B cell lineage tree saves as a png or pdf.\n\n        Parameters\n        ----------\n        fname : str\n            The filename where the visualization should be saved.  \n        isotype_encoding : list\n            The list of the isotype labels to use.  \n        show_legend : bool\n            Optionally display the legend of the isotype colors (default=True).  \n        show_labels : bool\n            label the nodes by the sequence label\n        hide_underscore : bool\n            internal nodes that undergo refinement will have an underscore and copy number appended\n            to the label. Setting this to true hides the underscore during visualization and retains \n            only the original label.\n        color_encoding : dict, optional\n            optional dictionary that maps isotype encoding to a color, if None, the default\n            color palette is used.\n        dot : bool\n            if the file should be saved as a dot file, otherwise it will be saved\n            as a png or pdf, depending on the file exentsion of fname\n        \"\"\"\n        parents = self.get_parents()\n        dt = DrawTree(parents, \n                    self.isotypes,\n                    show_legend=show_legend,\n                    root=self.root,\n                    isotype_encoding=isotype_encoding,\n                    show_labels=show_labels,\n                    hide_underscore=hide_underscore,\n                    color_encoding=color_encoding)\n        if not dot:\n            dt.save(fname)\n        else:\n            dt.save_dot(fname)\n\n\n    def postorder_traversal(self) -&gt; list:\n        \"\"\"Perform a postorder traversal of the lineage tree.\"\"\"\n        return self.tree.postorder_traversal()\n\n\n    def preorder_traversal(self) -&gt; list:\n        \"\"\"Perform a preorder traversal of the lineage tree.\"\"\"\n        return self.tree.preorder_traversal()\n\n    def parent(self,n):\n        \"\"\"Identify the parent of a specified node.\n\n        Parameters\n        ----------\n        n: str | int\n            id of query node.\n\n        Returns\n        -------\n           the parent of query node n.\n        \"\"\"\n        return self.tree.parent(n)\n\n    def children(self, n):\n        \"\"\"\n        Identify the set of children of a specified node.\n\n        Parameters\n        ----------\n        n : str\n            ID of the query node.  \n\n        Returns\n        -------\n            A list of children of node `n`.\n        \"\"\"\n        return self.tree.children(n)\n\n    def is_leaf(self,n):\n        \"\"\"Check if node is a leaf.\"\"\"\n        return self.tree.is_leaf(n)\n\n\n    def get_leafs(self):\n        \"\"\"\n        Identify the leafset of the lineage tree.\n\n        Returns\n        -------\n            the leafset of the lineage tree.\n\n        \"\"\"\n        return self.tree.get_leafs()\n\n    def get_parents(self):\n        \"\"\"Identify the part of each node in the lineage tree.\n\n        Returns\n        -------\n            a mapping of each node in the lineage tree to its parent node.\n\n        \"\"\"\n        return self.tree.get_parents()\n\n\n    def save_tree(self,fname):\n        \"\"\"Write the parent dictionary of the lineage tree to a file.\n\n        Parameters\n        ----------\n        fname : str\n            filename where the file should be saved \n        \"\"\"\n        parents = self.get_parents()\n        save_dict( parents, fname)\n\n    def save_edges(self, fname):\n        \"\"\"Write the edge list of a lineage tree to a file.\n\n        Parameters\n        ----------\n        fname : str\n            filename to where edge list should be saved \n        \"\"\"\n        self.tree.save_edges(fname)\n\n\n    def get_edge_dataframe(self):\n        \"\"\"Obtain the edge list of the lineage tree as a pandas.DataFrame.\"\"\"\n        return self.tree.get_edge_df()\n\n    def write(self, outpath:str, isotype_encoding=None, tree_label=None):\n        \"\"\"Write the lineage tree data to files.\n\n        Parameters\n        ----------\n        outpath : str\n            the path to file the files should be written.  \n        isotype_encoding : list, optional\n            the ordered isotype labels  \n        \"\"\"\n        if tree_label is None:\n            tree_label = \"\"\n        else:\n            tree_label = f\"{tree_label}\"\n        clono_name = self.clonotype\n        if isotype_encoding is not None:\n            isotypes = {}\n            for key, iso in self.isotypes.items():\n                if iso &gt;=0 and iso &lt; len(isotype_encoding):\n                    isotypes[key] = isotype_encoding[iso]\n                else:\n                    isotypes[key] = iso\n            isotype_encoding = isotype_encoding\n\n        else:\n            isotypes = self.isotypes\n            isotype_encoding = None\n\n\n        if not os.path.exists(outpath):\n            os.makedirs(outpath)\n\n        write_fasta(f\"{outpath}/{clono_name}_sequences{tree_label}.fasta\", self.sequences)\n        save_dict(f\"{outpath}/{clono_name}_isotypes{tree_label}.csv\",isotypes)\n        self.save_edges(f\"{outpath}/{clono_name}_edge_list{tree_label}.txt\")\n        self.draw(f\"{outpath}/{clono_name}_tree{tree_label}.png\",\n                    isotype_encoding=isotype_encoding,\n                    hide_underscore=False,\n                    show_legend=True)\n</code></pre>"},{"location":"api/lineagetree/#tribal.LineageTree.__eq__","title":"<code>__eq__(__value)</code>","text":"<p>Check if two lineage tree items have the same objective score.</p> Source code in <code>tribal/lineage_tree.py</code> <pre><code>def __eq__(self, __value: object) -&gt; bool:\n    \"\"\"Check if two lineage tree items have the same objective score.\"\"\"\n    item = self._validate_item(__value)\n    return self.objective ==item.objective\n</code></pre>"},{"location":"api/lineagetree/#tribal.LineageTree.__lt__","title":"<code>__lt__(__value)</code>","text":"<p>Check if a LineageTree is less than another.</p> Source code in <code>tribal/lineage_tree.py</code> <pre><code>def __lt__(self, __value: object) -&gt; bool:\n    \"\"\"Check if a LineageTree is less than another.\"\"\"\n    item = self._validate_item(__value)\n    return self.objective &lt;item.objective\n</code></pre>"},{"location":"api/lineagetree/#tribal.LineageTree.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Initialize the objective tuple and root.</p> Source code in <code>tribal/lineage_tree.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Initialize the objective tuple and root.\"\"\"\n    self.objective = (self.shm_obj,self.csr_obj)\n    self.root = self.tree.root\n</code></pre>"},{"location":"api/lineagetree/#tribal.LineageTree.__str__","title":"<code>__str__()</code>","text":"<p>To string method.</p> Source code in <code>tribal/lineage_tree.py</code> <pre><code>def __str__(self):\n    \"\"\"To string method.\"\"\"\n    mystr = f\"B cell lineage tree for {len(self.tree.get_leafs())} cells\"\n    mystr += f\"\\nRoot id: {self.root}\"\n    mystr += f\"# of nodes: {len(self.tree.T.nodes)}\"\n    mystr +=  f\"\\nObjective\\n----------\\nSHM: {self.shm_obj}\\nCSR: {self.csr_obj}\"\n    return mystr\n</code></pre>"},{"location":"api/lineagetree/#tribal.LineageTree.ancestral_sequence_reconstruction","title":"<code>ancestral_sequence_reconstruction(alignment, alphabet=('A', 'C', 'G', 'T', 'N', '-'), cost_function=None)</code>","text":"<p>Infer the ancestral BCR sequences of the internal nodes given an alignment.</p> <p>Parameters:</p> Name Type Description Default <code>alignment</code> <code>dict</code> <p>a dictionary with leaf labels and root id as keys and the BCR sequence as value.</p> required <code>alphabet</code> <code>tuple</code> <p>the valid alphabet for BCR sequences, default:  (\"A\", \"C\", \"G\", \"T\",\"N\", \"-\")</p> <code>('A', 'C', 'G', 'T', 'N', '-')</code> <code>cost_function</code> <code>dict | None</code> <p>the cost function for substitution of a single nucleotide base. If None, the  standard 0/1 cost function is used for matches and mismatches. If dictionary all pairs of the elements in the alpabet should be be includes in the keys.</p> <code>None</code> <p>Examples:</p> <p>Here is an example of how to reconstruct ancestral sequences::</p> <pre><code>    from tribal import clonotypes, LineageTree\n    id = \"Clonotype_1036\"\n    clonotype = clonotypes[id]\n    forest = clonotype.get_forest()\n    lt = LineageTree(id=id, tree = forest[0])\n    shm_score, sequences = lt.ancestral_sequence_reconstruction(clonotype.alignment)\n    print(lt)\n</code></pre> <p>Returns:</p> Type Description <code>float</code> <p>a float with the somatic hypermutation (SHM) parsimony score for the lineage tree</p> <code>dict</code> <p>a dictionary containing the BCR sequence labels of the lineage tree</p> Source code in <code>tribal/lineage_tree.py</code> <pre><code>def ancestral_sequence_reconstruction(self, alignment,\n                       alphabet=(\"A\", \"C\", \"G\", \"T\",\"N\", \"-\"), \n                       cost_function=None):\n    \"\"\"Infer the ancestral BCR sequences of the internal nodes given an alignment.\n\n    Parameters\n    ----------\n    alignment : dict\n        a dictionary with leaf labels and root id as keys and the BCR sequence as value.\n\n    alphabet : tuple\n        the valid alphabet for BCR sequences, default:  (\"A\", \"C\", \"G\", \"T\",\"N\", \"-\")\n\n    cost_function : dict|None\n        the cost function for substitution of a single nucleotide base. If None, the \n        standard 0/1 cost function is used for matches and mismatches. If dictionary\n        all pairs of the elements in the alpabet should be be includes in the keys.\n\n    Examples\n    --------\n    Here is an example of how to reconstruct ancestral sequences::\n\n    ```python  \n        from tribal import clonotypes, LineageTree\n        id = \"Clonotype_1036\"\n        clonotype = clonotypes[id]\n        forest = clonotype.get_forest()\n        lt = LineageTree(id=id, tree = forest[0])\n        shm_score, sequences = lt.ancestral_sequence_reconstruction(clonotype.alignment)\n        print(lt)\n    ```\n\n    Returns\n    -------\n    : float\n        a float with the somatic hypermutation (SHM) parsimony score for the lineage tree\n\n    : dict\n        a dictionary containing the BCR sequence labels of the lineage tree\n\n    \"\"\"     \n    alignment = {k: list(alignment[k]) for k in alignment}\n    sp = SmallParsimony(self.tree, \n                        alphabet= alphabet,\n                        cost = cost_function)\n    self.shm_obj, sequences = sp.sankoff(alignment)\n    self.sequences = {key : \"\".join(value) for key, value in sequences.items()}\n\n    return self.shm_obj, self.sequences\n</code></pre>"},{"location":"api/lineagetree/#tribal.LineageTree.children","title":"<code>children(n)</code>","text":"<p>Identify the set of children of a specified node.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>str</code> <p>ID of the query node.</p> required <p>Returns:</p> Type Description <code>    A list of children of node `n`.</code> Source code in <code>tribal/lineage_tree.py</code> <pre><code>def children(self, n):\n    \"\"\"\n    Identify the set of children of a specified node.\n\n    Parameters\n    ----------\n    n : str\n        ID of the query node.  \n\n    Returns\n    -------\n        A list of children of node `n`.\n    \"\"\"\n    return self.tree.children(n)\n</code></pre>"},{"location":"api/lineagetree/#tribal.LineageTree.compute_csr_likelihood","title":"<code>compute_csr_likelihood(transmat)</code>","text":"<p>Compute CSR likelihood of a lineage tree for a given isotype transition probability matrix.</p> <p>Parameters:</p> Name Type Description Default <code>transmat</code> <code>array</code> <p>The isotype transition probability used to compute the CSR likelihood.</p> required <p>Returns:</p> Type Description <code>    The class switch recombination (CSR) likelihood.</code> Source code in <code>tribal/lineage_tree.py</code> <pre><code>def compute_csr_likelihood(self, transmat):\n    \"\"\"Compute CSR likelihood of a lineage tree for a given isotype transition probability matrix.\n\n    Parameters\n    ----------\n    transmat : numpy.array\n        The isotype transition probability used to compute the CSR likelihood.\n\n    Returns\n    -------\n        The class switch recombination (CSR) likelihood.\n    \"\"\"\n    transmat = -np.log(transmat)\n\n    iso = self.isotypes\n    score = 0\n    try:\n        nodes = self.tree.preorder_traversal()\n        for n in nodes:\n            t = iso[n]\n            for c in self.tree.children(n):\n                s = iso[c]\n                score += transmat[t, s]\n    except:\n        raise ValueError(\"Invalid isotypes or tree. \\\n                         First run isotype parsimony or refinement functions.\")\n\n    self.csr_obj = score\n    return self.csr_obj\n</code></pre>"},{"location":"api/lineagetree/#tribal.LineageTree.draw","title":"<code>draw(fname, isotype_encoding=None, show_legend=False, show_labels=True, hide_underscore=True, color_encoding=None, dot=False)</code>","text":"<p>Visualization of the current B cell lineage tree saves as a png or pdf.</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>str</code> <p>The filename where the visualization should be saved.</p> required <code>isotype_encoding</code> <code>list</code> <p>The list of the isotype labels to use.</p> <code>None</code> <code>show_legend</code> <code>bool</code> <p>Optionally display the legend of the isotype colors (default=True).</p> <code>False</code> <code>show_labels</code> <code>bool</code> <p>label the nodes by the sequence label</p> <code>True</code> <code>hide_underscore</code> <code>bool</code> <p>internal nodes that undergo refinement will have an underscore and copy number appended to the label. Setting this to true hides the underscore during visualization and retains  only the original label.</p> <code>True</code> <code>color_encoding</code> <code>dict</code> <p>optional dictionary that maps isotype encoding to a color, if None, the default color palette is used.</p> <code>None</code> <code>dot</code> <code>bool</code> <p>if the file should be saved as a dot file, otherwise it will be saved as a png or pdf, depending on the file exentsion of fname</p> <code>False</code> Source code in <code>tribal/lineage_tree.py</code> <pre><code>def draw(self,\n        fname,\n        isotype_encoding=None,\n        show_legend=False,\n        show_labels=True,\n        hide_underscore=True,\n        color_encoding = None,\n        dot = False):\n    \"\"\"Visualization of the current B cell lineage tree saves as a png or pdf.\n\n    Parameters\n    ----------\n    fname : str\n        The filename where the visualization should be saved.  \n    isotype_encoding : list\n        The list of the isotype labels to use.  \n    show_legend : bool\n        Optionally display the legend of the isotype colors (default=True).  \n    show_labels : bool\n        label the nodes by the sequence label\n    hide_underscore : bool\n        internal nodes that undergo refinement will have an underscore and copy number appended\n        to the label. Setting this to true hides the underscore during visualization and retains \n        only the original label.\n    color_encoding : dict, optional\n        optional dictionary that maps isotype encoding to a color, if None, the default\n        color palette is used.\n    dot : bool\n        if the file should be saved as a dot file, otherwise it will be saved\n        as a png or pdf, depending on the file exentsion of fname\n    \"\"\"\n    parents = self.get_parents()\n    dt = DrawTree(parents, \n                self.isotypes,\n                show_legend=show_legend,\n                root=self.root,\n                isotype_encoding=isotype_encoding,\n                show_labels=show_labels,\n                hide_underscore=hide_underscore,\n                color_encoding=color_encoding)\n    if not dot:\n        dt.save(fname)\n    else:\n        dt.save_dot(fname)\n</code></pre>"},{"location":"api/lineagetree/#tribal.LineageTree.get_edge_dataframe","title":"<code>get_edge_dataframe()</code>","text":"<p>Obtain the edge list of the lineage tree as a pandas.DataFrame.</p> Source code in <code>tribal/lineage_tree.py</code> <pre><code>def get_edge_dataframe(self):\n    \"\"\"Obtain the edge list of the lineage tree as a pandas.DataFrame.\"\"\"\n    return self.tree.get_edge_df()\n</code></pre>"},{"location":"api/lineagetree/#tribal.LineageTree.get_id","title":"<code>get_id()</code>","text":"<p>Get the internal id of the tree topology. Useful for mapping refined trees back the to the unrefined tree in the parsimony forest.</p> <p>Returns:</p> Type Description <code>int</code> <p>the internal id of the tree topology</p> Source code in <code>tribal/lineage_tree.py</code> <pre><code>def get_id(self):\n    \"\"\"Get the internal id of the tree topology. Useful for mapping refined trees back the to the unrefined tree in the parsimony forest.\n\n    Returns\n    -------\n    : int\n        the internal id of the tree topology\n    \"\"\"\n    return self.tree.id\n</code></pre>"},{"location":"api/lineagetree/#tribal.LineageTree.get_leafs","title":"<code>get_leafs()</code>","text":"<p>Identify the leafset of the lineage tree.</p> <p>Returns:</p> Type Description <code>    the leafset of the lineage tree.</code> Source code in <code>tribal/lineage_tree.py</code> <pre><code>def get_leafs(self):\n    \"\"\"\n    Identify the leafset of the lineage tree.\n\n    Returns\n    -------\n        the leafset of the lineage tree.\n\n    \"\"\"\n    return self.tree.get_leafs()\n</code></pre>"},{"location":"api/lineagetree/#tribal.LineageTree.get_parents","title":"<code>get_parents()</code>","text":"<p>Identify the part of each node in the lineage tree.</p> <p>Returns:</p> Type Description <code>    a mapping of each node in the lineage tree to its parent node.</code> Source code in <code>tribal/lineage_tree.py</code> <pre><code>def get_parents(self):\n    \"\"\"Identify the part of each node in the lineage tree.\n\n    Returns\n    -------\n        a mapping of each node in the lineage tree to its parent node.\n\n    \"\"\"\n    return self.tree.get_parents()\n</code></pre>"},{"location":"api/lineagetree/#tribal.LineageTree.is_leaf","title":"<code>is_leaf(n)</code>","text":"<p>Check if node is a leaf.</p> Source code in <code>tribal/lineage_tree.py</code> <pre><code>def is_leaf(self,n):\n    \"\"\"Check if node is a leaf.\"\"\"\n    return self.tree.is_leaf(n)\n</code></pre>"},{"location":"api/lineagetree/#tribal.LineageTree.isotype_parsimony","title":"<code>isotype_parsimony(isotype_labels, transmat)</code>","text":"<p>Infer the isotype of the B cell lineage tree using weighted parsimony.</p> <p>Parameters:</p> Name Type Description Default <code>isotype_labels</code> <code>dict</code> <p>a dictionary with leaf labels and root id as keys and isotypes as values.</p> required <code>transmat</code> <code>array</code> <p>the isotype transition probability used to compute the CSR likelihood.</p> required <p>Examples:</p> <p>Here is an example of how to infer isotypes::</p> <pre><code>    from tribal import clonotypes, probabilities, LineageTree\n\n    id = \"Clonotype_1036\"\n    clonotype = clonotypes[id]\n    forest = clonotype.get_forest()\n    lt = LineageTree(id=id, tree = forest[0] )\n    csr_likelihood, isotypes = lt.isotype_parsimony(isotype_labels= clonotype.isotypes,\n                                                                transmat=probabilities )\n    print(lt)\n</code></pre> <p>Returns:</p> Name Type Description <code>csr_obj</code> <code>float</code> <p>a float with the class switch recombination likelihood score for the lineage tree.  </p> <code>isotypes</code> <code>dict</code> <p>a dictionary containing the isotypes of the lineage tree.</p> Source code in <code>tribal/lineage_tree.py</code> <pre><code>def isotype_parsimony(self, isotype_labels:dict, transmat:np.array):\n    \"\"\"Infer the isotype of the B cell lineage tree using weighted parsimony.\n\n    Parameters\n    ----------\n    isotype_labels : dict\n        a dictionary with leaf labels and root id as keys and isotypes as values.  \n    transmat : numpy.array\n        the isotype transition probability used to compute the CSR likelihood.  \n\n    Examples\n    --------\n    Here is an example of how to infer isotypes::\n\n    ```python\n        from tribal import clonotypes, probabilities, LineageTree\n\n        id = \"Clonotype_1036\"\n        clonotype = clonotypes[id]\n        forest = clonotype.get_forest()\n        lt = LineageTree(id=id, tree = forest[0] )\n        csr_likelihood, isotypes = lt.isotype_parsimony(isotype_labels= clonotype.isotypes,\n                                                                    transmat=probabilities )\n        print(lt)\n    ```\n\n    Returns\n    -------\n    csr_obj : float\n        a float with the class switch recombination likelihood score for the lineage tree.  \n    isotypes : dict\n        a dictionary containing the isotypes of the lineage tree.  \n    \"\"\"\n    transmat = -np.log(transmat)\n    states = list(range(transmat.shape[0]))\n    sp = SmallParsimony(self.tree, alphabet=states,cost=transmat)\n    self.csr_obj, self.isotypes = sp.sankoff(isotype_labels)\n</code></pre>"},{"location":"api/lineagetree/#tribal.LineageTree.parent","title":"<code>parent(n)</code>","text":"<p>Identify the parent of a specified node.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <p>id of query node.</p> required <p>Returns:</p> Type Description <code>   the parent of query node n.</code> Source code in <code>tribal/lineage_tree.py</code> <pre><code>def parent(self,n):\n    \"\"\"Identify the parent of a specified node.\n\n    Parameters\n    ----------\n    n: str | int\n        id of query node.\n\n    Returns\n    -------\n       the parent of query node n.\n    \"\"\"\n    return self.tree.parent(n)\n</code></pre>"},{"location":"api/lineagetree/#tribal.LineageTree.postorder_traversal","title":"<code>postorder_traversal()</code>","text":"<p>Perform a postorder traversal of the lineage tree.</p> Source code in <code>tribal/lineage_tree.py</code> <pre><code>def postorder_traversal(self) -&gt; list:\n    \"\"\"Perform a postorder traversal of the lineage tree.\"\"\"\n    return self.tree.postorder_traversal()\n</code></pre>"},{"location":"api/lineagetree/#tribal.LineageTree.preorder_traversal","title":"<code>preorder_traversal()</code>","text":"<p>Perform a preorder traversal of the lineage tree.</p> Source code in <code>tribal/lineage_tree.py</code> <pre><code>def preorder_traversal(self) -&gt; list:\n    \"\"\"Perform a preorder traversal of the lineage tree.\"\"\"\n    return self.tree.preorder_traversal()\n</code></pre>"},{"location":"api/lineagetree/#tribal.LineageTree.refinement","title":"<code>refinement(isotype_labels, transmat)</code>","text":"<p>Solves the most parsimonious tree refinement problem (MPTR).</p> <p>Parameters:</p> Name Type Description Default <code>isotype_labels</code> <code>dict</code> <p>A dictionary with leaf labels and root id as keys and isotypes as values.</p> required <code>transmat</code> <code>array</code> <p>The isotype transition probability used to compute the CSR likelihood.</p> required <p>Examples:</p> <p>Here is an example of how to refine a lineage tree:</p> <pre><code>from tribal import clonotypes, probabilities, LineageTree\n\nid = \"Clonotype_1036\"\nclonotype = clonotypes[id]\nforest = clonotype.get_forest()\nlt = LineageTree(id=id, tree=forest[0])\ncsr_likelihood, isotypes = lt.refinement(isotype_labels=clonotype.isotypes, transmat=probabilities)\nprint(lt)\n</code></pre> <p>Returns:</p> Type Description <code>float</code> <p>A float with the class switch recombination likelihood score for the lineage tree.  </p> <code>dict</code> <p>A dictionary containing the isotypes of the lineage tree.</p> Source code in <code>tribal/lineage_tree.py</code> <pre><code>def refinement(self, isotype_labels: Dict[str, str], transmat: np.ndarray) -&gt; Tuple[float, Dict[str, str]]:\n    \"\"\"Solves the most parsimonious tree refinement problem (MPTR).\n\n    Parameters\n    ----------\n    isotype_labels : dict\n        A dictionary with leaf labels and root id as keys and isotypes as values.\n    transmat : numpy.array\n        The isotype transition probability used to compute the CSR likelihood.\n\n    Examples\n    --------\n    Here is an example of how to refine a lineage tree:\n\n    ```python\n    from tribal import clonotypes, probabilities, LineageTree\n\n    id = \"Clonotype_1036\"\n    clonotype = clonotypes[id]\n    forest = clonotype.get_forest()\n    lt = LineageTree(id=id, tree=forest[0])\n    csr_likelihood, isotypes = lt.refinement(isotype_labels=clonotype.isotypes, transmat=probabilities)\n    print(lt)\n    ```\n\n    Returns\n    -------\n    float\n        A float with the class switch recombination likelihood score for the lineage tree.  \n\n    dict\n        A dictionary containing the isotypes of the lineage tree.  \n    \"\"\"\n    cost = -np.log(transmat)\n    cg = ConstructGraph(cost, isotype_labels, root_identifier=self.root)\n    fg = cg.build(self.tree)\n\n    st = MPTR(fg.G,\n              self.tree.T,\n              fg.find_terminals(),\n              fg.iso_weights,\n              fg.tree_to_graph,\n              root=self.root)\n\n    self.csr_obj, tree = st.run()\n\n    tree, self.isotypes = cg.decodeTree(tree)\n    self.tree = BaseTree(tree, self.root, self.tree.id, self.tree.name)\n\n    return self.csr_obj, self.isotypes\n</code></pre>"},{"location":"api/lineagetree/#tribal.LineageTree.save_edges","title":"<code>save_edges(fname)</code>","text":"<p>Write the edge list of a lineage tree to a file.</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>str</code> <p>filename to where edge list should be saved</p> required Source code in <code>tribal/lineage_tree.py</code> <pre><code>def save_edges(self, fname):\n    \"\"\"Write the edge list of a lineage tree to a file.\n\n    Parameters\n    ----------\n    fname : str\n        filename to where edge list should be saved \n    \"\"\"\n    self.tree.save_edges(fname)\n</code></pre>"},{"location":"api/lineagetree/#tribal.LineageTree.save_tree","title":"<code>save_tree(fname)</code>","text":"<p>Write the parent dictionary of the lineage tree to a file.</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>str</code> <p>filename where the file should be saved</p> required Source code in <code>tribal/lineage_tree.py</code> <pre><code>def save_tree(self,fname):\n    \"\"\"Write the parent dictionary of the lineage tree to a file.\n\n    Parameters\n    ----------\n    fname : str\n        filename where the file should be saved \n    \"\"\"\n    parents = self.get_parents()\n    save_dict( parents, fname)\n</code></pre>"},{"location":"api/lineagetree/#tribal.LineageTree.to_pickle","title":"<code>to_pickle(fname)</code>","text":"<p>Pickle the B cell lineage tree.</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>str</code> <p>the path to where the pickled object should be saved,</p> required Source code in <code>tribal/lineage_tree.py</code> <pre><code>def to_pickle(self, fname):\n    \"\"\"Pickle the B cell lineage tree.\n\n    Parameters\n    ----------\n    fname : str\n        the path to where the pickled object should be saved,\n    \"\"\"\n    with open(fname, 'wb') as file:\n        pickle.dump(self, file)\n</code></pre>"},{"location":"api/lineagetree/#tribal.LineageTree.write","title":"<code>write(outpath, isotype_encoding=None, tree_label=None)</code>","text":"<p>Write the lineage tree data to files.</p> <p>Parameters:</p> Name Type Description Default <code>outpath</code> <code>str</code> <p>the path to file the files should be written.</p> required <code>isotype_encoding</code> <code>list</code> <p>the ordered isotype labels</p> <code>None</code> Source code in <code>tribal/lineage_tree.py</code> <pre><code>def write(self, outpath:str, isotype_encoding=None, tree_label=None):\n    \"\"\"Write the lineage tree data to files.\n\n    Parameters\n    ----------\n    outpath : str\n        the path to file the files should be written.  \n    isotype_encoding : list, optional\n        the ordered isotype labels  \n    \"\"\"\n    if tree_label is None:\n        tree_label = \"\"\n    else:\n        tree_label = f\"{tree_label}\"\n    clono_name = self.clonotype\n    if isotype_encoding is not None:\n        isotypes = {}\n        for key, iso in self.isotypes.items():\n            if iso &gt;=0 and iso &lt; len(isotype_encoding):\n                isotypes[key] = isotype_encoding[iso]\n            else:\n                isotypes[key] = iso\n        isotype_encoding = isotype_encoding\n\n    else:\n        isotypes = self.isotypes\n        isotype_encoding = None\n\n\n    if not os.path.exists(outpath):\n        os.makedirs(outpath)\n\n    write_fasta(f\"{outpath}/{clono_name}_sequences{tree_label}.fasta\", self.sequences)\n    save_dict(f\"{outpath}/{clono_name}_isotypes{tree_label}.csv\",isotypes)\n    self.save_edges(f\"{outpath}/{clono_name}_edge_list{tree_label}.txt\")\n    self.draw(f\"{outpath}/{clono_name}_tree{tree_label}.png\",\n                isotype_encoding=isotype_encoding,\n                hide_underscore=False,\n                show_legend=True)\n</code></pre>"},{"location":"api/lineagetreelist/","title":"B cell Lineage Tree","text":"<p>               Bases: <code>list</code></p> <p>Extends class list in order to store and manipulate list of LineageTrees.</p> Source code in <code>tribal/lineage_tree.py</code> <pre><code>class LineageTreeList(list):\n    \"\"\"Extends class list in order to store and manipulate list of LineageTrees.\"\"\"\n\n    def __str__(self) -&gt; str:\n        \"\"\"To string method.\"\"\"\n        return f\"{type(self)} with {len(self)} LineageTree(s).\"\n\n    def append(self, item):\n        \"\"\"Append a LineageTree to the LineageTreeList.\"\"\"\n        super().append(self._validate_item(item))\n\n    #only Score objects are allowd in\n    def _validate_item(self, item):\n        if isinstance(item, (LineageTree)):\n            return item\n        raise TypeError(\n            f\"Score expected, item got {type(item).__name__}\"\n        )\n\n    def write(self, fname:str, sep=\",\"):\n        \"\"\"Write the objective scores of all LineageTrees in the list to a file.\n\n        Parameters\n        ----------\n        fname : str\n            path to where file should be written.\n        sep : str\n            the seperator (default: \",\").\n        \"\"\"\n        with open(fname,'w+') as file:\n            file.write(f\"id{sep}shm_score{sep}csr_likelihood\\n\")\n\n            for score in self:\n\n                file.write(f\"{score.tree.id}{sep}{score.objective}{sep}{score.seq_score}{sep}{score.iso_score}{sep}\\n\")\n\n    def find_best_tree(self):\n        \"\"\"Find the LineageTree with optimal score.\n\n        If there are multiple optimal solutions, it returns the first one it finds.  \n        See `find_all_best_trees` to get all optimal solutions in the LineageTreeList or `sample_best_trees` to randomly \n        sample from among the optimal LineageTrees.\n\n        Returns\n        ----------\n        float\n            the optimal CSR likelihood of the best LineageTree\n\n        LineageTree\n            a LineageTree with optimal CSR likelihood\n        \"\"\"\n        min_score = min(self, key=lambda x: x.objective).csr_obj\n\n        # Filter objects with the minimum score\n        min_score_object = [obj for obj in self if round(obj.csr_obj, 5) == round(min_score,5)][0]\n        return min_score, [min_score_object]\n\n    def find_all_best_trees(self):\n        \"\"\"Find the LineageTree(s) with optimal scores.\n\n        Returns\n        -------\n        float\n            the optimal CSR likelihood of the best LineageTree.\n\n        LineageTreeList\n            a LineageTreeList of LineageTree with optimal CSR likelihood.\n        \"\"\"\n        min_score = min(self, key=lambda x: x.csr_obj).csr_obj\n\n\n        min_score_object = [obj for obj in self if round(obj.csr_obj, 5) == round(min_score,5)]\n        min_score_object = LineageTreeList(min_score_object)\n        return min_score, min_score_object\n\n    def _get_all_trees(self):\n\n        return [x.tree for x in self]\n\n    def _get_ids(self):\n        return [x.get_id() for x in self]\n\n    def to_pickle(self, fname):\n        \"\"\"Pickle the LineageTreeList.\n\n        Parameters\n        ----------\n        fname : str\n            the path to where the pickled object should be saved.\n        \"\"\"\n        with open(fname, 'wb') as file:\n            pickle.dump(self, file)\n\n    def sample_best_tree(self, rng=None, seed=1016):\n        \"\"\"Find a LineageTree with optimal score.\n\n        If there are multiple optimal solutions, it randomly samples among the lineage trees with optimal solutions.  \n        See `find_all_best_trees` to get all optimal solutions in the LineageTreeList or `find_best_tree` to randomly \n        sample from among the optimal LineageTrees.\n\n        Parameters\n        ----------\n        rng : numpy.random.Generator\n            a numpy random number generator to use for sampling. (default: None)\n        seed : int\n            a random number seed to use to initialize a numpy.random.Generator (default: 1016)\n\n        Returns\n        ----------\n        LineageTree\n            a randomly sampled LineageTree with optimal CSR likelihood\n        \"\"\"\n        if rng is None:\n            rng = np.random.default_rng(seed)\n        _, best_scores = self.find_all_best_trees()\n        sampled_index = np.random.choice(len(best_scores))\n        return best_scores[sampled_index]\n\n\n\n    def write_all(self, outpath, isotype_encoding=None):\n        \"\"\"Write the data for all LineageTrees in the list to files.\n\n        Parameters\n        ----------\n        outpath : str\n            the path to where the files should be written.\n        isotype_encoding : list\n            the ordered isotype labeles\n        \"\"\"\n        for i,lt in enumerate(self):\n            lt.write(outpath,isotype_encoding=isotype_encoding, tree_label=i)\n</code></pre>"},{"location":"api/lineagetreelist/#tribal.LineageTreeList.__str__","title":"<code>__str__()</code>","text":"<p>To string method.</p> Source code in <code>tribal/lineage_tree.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"To string method.\"\"\"\n    return f\"{type(self)} with {len(self)} LineageTree(s).\"\n</code></pre>"},{"location":"api/lineagetreelist/#tribal.LineageTreeList.append","title":"<code>append(item)</code>","text":"<p>Append a LineageTree to the LineageTreeList.</p> Source code in <code>tribal/lineage_tree.py</code> <pre><code>def append(self, item):\n    \"\"\"Append a LineageTree to the LineageTreeList.\"\"\"\n    super().append(self._validate_item(item))\n</code></pre>"},{"location":"api/lineagetreelist/#tribal.LineageTreeList.find_all_best_trees","title":"<code>find_all_best_trees()</code>","text":"<p>Find the LineageTree(s) with optimal scores.</p> <p>Returns:</p> Type Description <code>float</code> <p>the optimal CSR likelihood of the best LineageTree.</p> <code>LineageTreeList</code> <p>a LineageTreeList of LineageTree with optimal CSR likelihood.</p> Source code in <code>tribal/lineage_tree.py</code> <pre><code>def find_all_best_trees(self):\n    \"\"\"Find the LineageTree(s) with optimal scores.\n\n    Returns\n    -------\n    float\n        the optimal CSR likelihood of the best LineageTree.\n\n    LineageTreeList\n        a LineageTreeList of LineageTree with optimal CSR likelihood.\n    \"\"\"\n    min_score = min(self, key=lambda x: x.csr_obj).csr_obj\n\n\n    min_score_object = [obj for obj in self if round(obj.csr_obj, 5) == round(min_score,5)]\n    min_score_object = LineageTreeList(min_score_object)\n    return min_score, min_score_object\n</code></pre>"},{"location":"api/lineagetreelist/#tribal.LineageTreeList.find_best_tree","title":"<code>find_best_tree()</code>","text":"<p>Find the LineageTree with optimal score.</p> <p>If there are multiple optimal solutions, it returns the first one it finds. See <code>find_all_best_trees</code> to get all optimal solutions in the LineageTreeList or <code>sample_best_trees</code> to randomly  sample from among the optimal LineageTrees.</p> <p>Returns:</p> Type Description <code>float</code> <p>the optimal CSR likelihood of the best LineageTree</p> <code>LineageTree</code> <p>a LineageTree with optimal CSR likelihood</p> Source code in <code>tribal/lineage_tree.py</code> <pre><code>def find_best_tree(self):\n    \"\"\"Find the LineageTree with optimal score.\n\n    If there are multiple optimal solutions, it returns the first one it finds.  \n    See `find_all_best_trees` to get all optimal solutions in the LineageTreeList or `sample_best_trees` to randomly \n    sample from among the optimal LineageTrees.\n\n    Returns\n    ----------\n    float\n        the optimal CSR likelihood of the best LineageTree\n\n    LineageTree\n        a LineageTree with optimal CSR likelihood\n    \"\"\"\n    min_score = min(self, key=lambda x: x.objective).csr_obj\n\n    # Filter objects with the minimum score\n    min_score_object = [obj for obj in self if round(obj.csr_obj, 5) == round(min_score,5)][0]\n    return min_score, [min_score_object]\n</code></pre>"},{"location":"api/lineagetreelist/#tribal.LineageTreeList.sample_best_tree","title":"<code>sample_best_tree(rng=None, seed=1016)</code>","text":"<p>Find a LineageTree with optimal score.</p> <p>If there are multiple optimal solutions, it randomly samples among the lineage trees with optimal solutions. See <code>find_all_best_trees</code> to get all optimal solutions in the LineageTreeList or <code>find_best_tree</code> to randomly  sample from among the optimal LineageTrees.</p> <p>Parameters:</p> Name Type Description Default <code>rng</code> <code>Generator</code> <p>a numpy random number generator to use for sampling. (default: None)</p> <code>None</code> <code>seed</code> <code>int</code> <p>a random number seed to use to initialize a numpy.random.Generator (default: 1016)</p> <code>1016</code> <p>Returns:</p> Type Description <code>LineageTree</code> <p>a randomly sampled LineageTree with optimal CSR likelihood</p> Source code in <code>tribal/lineage_tree.py</code> <pre><code>def sample_best_tree(self, rng=None, seed=1016):\n    \"\"\"Find a LineageTree with optimal score.\n\n    If there are multiple optimal solutions, it randomly samples among the lineage trees with optimal solutions.  \n    See `find_all_best_trees` to get all optimal solutions in the LineageTreeList or `find_best_tree` to randomly \n    sample from among the optimal LineageTrees.\n\n    Parameters\n    ----------\n    rng : numpy.random.Generator\n        a numpy random number generator to use for sampling. (default: None)\n    seed : int\n        a random number seed to use to initialize a numpy.random.Generator (default: 1016)\n\n    Returns\n    ----------\n    LineageTree\n        a randomly sampled LineageTree with optimal CSR likelihood\n    \"\"\"\n    if rng is None:\n        rng = np.random.default_rng(seed)\n    _, best_scores = self.find_all_best_trees()\n    sampled_index = np.random.choice(len(best_scores))\n    return best_scores[sampled_index]\n</code></pre>"},{"location":"api/lineagetreelist/#tribal.LineageTreeList.to_pickle","title":"<code>to_pickle(fname)</code>","text":"<p>Pickle the LineageTreeList.</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>str</code> <p>the path to where the pickled object should be saved.</p> required Source code in <code>tribal/lineage_tree.py</code> <pre><code>def to_pickle(self, fname):\n    \"\"\"Pickle the LineageTreeList.\n\n    Parameters\n    ----------\n    fname : str\n        the path to where the pickled object should be saved.\n    \"\"\"\n    with open(fname, 'wb') as file:\n        pickle.dump(self, file)\n</code></pre>"},{"location":"api/lineagetreelist/#tribal.LineageTreeList.write","title":"<code>write(fname, sep=',')</code>","text":"<p>Write the objective scores of all LineageTrees in the list to a file.</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>str</code> <p>path to where file should be written.</p> required <code>sep</code> <code>str</code> <p>the seperator (default: \",\").</p> <code>','</code> Source code in <code>tribal/lineage_tree.py</code> <pre><code>def write(self, fname:str, sep=\",\"):\n    \"\"\"Write the objective scores of all LineageTrees in the list to a file.\n\n    Parameters\n    ----------\n    fname : str\n        path to where file should be written.\n    sep : str\n        the seperator (default: \",\").\n    \"\"\"\n    with open(fname,'w+') as file:\n        file.write(f\"id{sep}shm_score{sep}csr_likelihood\\n\")\n\n        for score in self:\n\n            file.write(f\"{score.tree.id}{sep}{score.objective}{sep}{score.seq_score}{sep}{score.iso_score}{sep}\\n\")\n</code></pre>"},{"location":"api/lineagetreelist/#tribal.LineageTreeList.write_all","title":"<code>write_all(outpath, isotype_encoding=None)</code>","text":"<p>Write the data for all LineageTrees in the list to files.</p> <p>Parameters:</p> Name Type Description Default <code>outpath</code> <code>str</code> <p>the path to where the files should be written.</p> required <code>isotype_encoding</code> <code>list</code> <p>the ordered isotype labeles</p> <code>None</code> Source code in <code>tribal/lineage_tree.py</code> <pre><code>def write_all(self, outpath, isotype_encoding=None):\n    \"\"\"Write the data for all LineageTrees in the list to files.\n\n    Parameters\n    ----------\n    outpath : str\n        the path to where the files should be written.\n    isotype_encoding : list\n        the ordered isotype labeles\n    \"\"\"\n    for i,lt in enumerate(self):\n        lt.write(outpath,isotype_encoding=isotype_encoding, tree_label=i)\n</code></pre>"},{"location":"api/preprocess/","title":"Preprocessing","text":"<p>A module to preprocess data for TRIBAL.</p>"},{"location":"api/preprocess/#tribal.preprocess.preprocess","title":"<code>preprocess(df, roots, isotypes, min_size=4, use_light_chain=True, cores=1, verbose=False)</code>","text":"<p>Preprocess the input data to prepare data for TRIBAL.</p> <p>The clonotypes will first be filtered to ensure each clonotype has at least <code>min_size</code> cells. Each retained clonotype is aligned to the root sequence and then maximum parsimony forest is enumerated for the B cells with that clonotype.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>A dataframe with columns including 'clonotype', 'heavy_chain_seq', 'light_chain_seq', 'heavy_chain_v_allele', 'light_chain_v_allele', and 'heavy_chain_isotype'. The 'Light Chain' columns are optional.</p> required <code>roots</code> <code>DataFrame</code> <p>A dataframe containing the root sequences.</p> required <code>isotypes</code> <code>list</code> <p>A list of the ordered isotype labels, i.e., ['IghM', ...,'IghA']. These labels should match the isotype labels in the input dataframe. See notes below.</p> required <code>min_size</code> <code>int</code> <p>The minimum number of B cells needed to form a clonotype (default is 4).</p> <code>4</code> <code>use_light_chain</code> <code>bool</code> <p>Should the light chain be included in the BCR sequences (default is True).</p> <code>True</code> <code>cores</code> <code>int</code> <p>The number of CPU cores to use (default is 1).</p> <code>1</code> <code>verbose</code> <code>bool</code> <p>Should verbose output be printed (default is False).</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of clonotype objects formatted for input to tribal with clonotype id as key</p> <code>DataFrame</code> <p>A dataframe that is filtered to contain only unfiltered B cells</p> Notes <p>Ensure that the isotype labels in <code>isotypes</code> match the labels in the input dataframe.</p> Source code in <code>tribal/preprocess.py</code> <pre><code>def preprocess( df: pd.DataFrame,\n            roots: pd.DataFrame,\n            isotypes:list,\n            min_size=4,\n            use_light_chain=True,\n            cores:int =1,\n            verbose=False\n            ):\n    \"\"\"\n    Preprocess the input data to prepare data for TRIBAL.\n\n    The clonotypes will first be filtered to ensure each clonotype has at least `min_size` cells.\n    Each retained clonotype is aligned to the root sequence and then maximum parsimony forest is\n    enumerated for the B cells with that clonotype.\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        A dataframe with columns including 'clonotype', 'heavy_chain_seq', 'light_chain_seq',\n        'heavy_chain_v_allele', 'light_chain_v_allele', and 'heavy_chain_isotype'.\n        The 'Light Chain' columns are optional.\n    roots : pd.DataFrame\n        A dataframe containing the root sequences.\n    isotypes : list\n        A list of the ordered isotype labels, i.e., ['IghM', ...,'IghA']. These labels should\n        match the isotype labels in the input dataframe. See notes below.  \n    min_size : int, optional\n        The minimum number of B cells needed to form a clonotype (default is 4).  \n    use_light_chain : bool, optional\n        Should the light chain be included in the BCR sequences (default is True).  \n    cores : int, optional\n        The number of CPU cores to use (default is 1).  \n    verbose : bool, optional\n        Should verbose output be printed (default is False).  \n\n    Returns\n    -------\n    dict \n        A dictionary of clonotype objects formatted for input to tribal with clonotype id as key\n    pd.DataFrame\n        A dataframe that is filtered to contain only unfiltered B cells\n\n    Notes\n    -----\n    Ensure that the isotype labels in `isotypes` match the labels in the input dataframe.\n    \"\"\"\n    isotype = {iso: i for i, iso in enumerate(isotypes)}\n    if verbose:\n        print(\"\\nPreprocessing input data for tribal...\")\n        print(\"\\nIsotype ordering:\")\n        for iso in isotypes:\n            print(iso)\n        print(\"\\nParameter settings:\")\n        print(f\"minimum clonotype size: {min_size}\")\n        print(f\"include light chain: {use_light_chain}\")\n        print(f\"cores: {cores}\")\n        print(f\"verbose: {verbose}\")\n\n\n    #first filter out clonotypes smaller than min size\n    if verbose:\n\n        print(\"\\nPrior to filtering...\")\n        print(f\"The number of cells is {df.shape[0]} and the number of clonotypes is {df['clonotype'].nunique()}.\")\n\n    df = df.groupby(\"clonotype\").filter(lambda x: len(x) &gt;= min_size)\n\n    df = df[df[\"heavy_chain_isotype\"].isin(isotype.keys())]\n\n    if verbose:\n        print(f\"\\nFiltering clonotypes with fewer than {min_size} cells...\")\n        print(f\"The number of cells is {df.shape[0]} and the number of clonotypes is {df['clonotype'].nunique()}.\")\n\n    df = _filter_alleles(df, \"heavy_chain_v_allele\")\n    if use_light_chain:\n        df = _filter_alleles(df, \"light_chain_v_allele\")\n    df = df[ df['heavy_chain_isotype'].notna()]\n\n    df = df.groupby(\"clonotype\").filter(lambda x: len(x) &gt;= min_size)\n\n    if verbose:\n        print(f\"\\nFiltering cells based on v_alleles {min_size}...\")\n\n        print(f\"The number of cells is {df.shape[0]} and the number of clonotypes is {df['clonotype'].nunique()}.\")\n\n    if verbose:\n        print(f\"\\nAfter all filtering, the number of cells is {df.shape[0]} and the number of clonotypes is {df['clonotype'].nunique()}.\\n\")\n\n    #prep dnapars sequence ids\n    df['seq'] = df.groupby('clonotype').cumcount() + 1\n    df['seq'] = 'seq' + df['seq'].astype(str)\n\n    df.columns.values[0] = \"cellid\"\n    roots.columns.values[0] = \"clonotype\"\n    df[\"isotype\"] = df['heavy_chain_isotype'].map(isotype)\n\n    clonodict = {}    \n    instances  = [ (j, df.copy(), roots.copy(), use_light_chain, isotypes, verbose)\n                   for j in df[\"clonotype\"].unique()]\n    if cores &gt; 1:\n        with mp.Pool(cores) as pool:\n            results = pool.starmap(_process_clonotype, instances)\n    else:\n        results = []\n        for inst in instances:\n            results.append(_process_clonotype(*inst))\n\n    for j, linforest in results:\n        clonodict[j] = linforest\n\n    if verbose:\n        print(\"\\nPreprocessing complete!\")\n    return clonodict, df\n</code></pre>"},{"location":"api/tribal/","title":"Tribal","text":"<p>A class to infer a B cell lineage tree for each clonotype and shared isotype transition probabilities. </p> <p>Attributes:</p> Name Type Description <code>n_isotypes</code> <code>int</code> <p>the number of isotype states</p> <code>alphabet</code> <code>tuple</code> <p>the valid alphabet for BCR sequences, defaults to  (\"A\", \"C\", \"G\", \"T\",\"N\", \"-\")</p> <code>sankoff_cost_function</code> <code>dict</code> <p>the cost function to use for running the Sankoff algorithm during ancestral BCR sequence reconstruction. the keys must be all pairs from the provided alphabet. defaults to using the standard cost function (1 for a mismatch, 0 for match)</p> <code>seed</code> <code>int</code> <p>random number seed used to randomly downsample candidate trees within each iterations when size of a parsimony forests is greater than max_cand</p> <code>max_cand</code> <code>int</code> <p>the maximum allowable size of a parsimony forest to consider within each coordinate descent iterations. if the size of each maximum parsimony forest is less than max_cand then downsampling does not occur. niter: int the maximum number of coordinate descent iterations to perform if convergence criteria is not met, defaults to 10)</p> <code>threshold</code> <code>float</code> <p>The tolerance for convergence of the CSR objective, defaults to 0.5</p> <code>restarts</code> <code>int</code> <p>the number of restarts, i.e, different initialization of the isotype transition probabilities, defaults to 10</p> <code>stay_probs</code> <code>tuple</code> <p>the lower bound and upper bound for the initialization of the probability of not class switching. the initalization values of this parameter are determined by using np.linspace on this range with the restarts parameter, defaults to (0.55, 0.95)</p> Notes <p>TRIBAL takes as input a maximum parsimony forest (a set of trees that minimizes the SHM score for a  multiple sequenced alignment of the concatentated heavy and light chain (optional) variable region sequences) and the encoded isotype of each sequenced B cell for k clonotypes.   See the Preprocessor class for help preparing the input data.  It then infers a B cell lineage tree(s) for each clonotype that minimizes the somatic hypermutation (SHM) parsimony score and then maximizes the class swtich recombination (CSR) likelihood score. It also infers the optimal isotype transition probabilities that jointly maximizes the CSR likelihood.</p> <p>TRIBAL uses a coordinate ascent algorithm to alternately infer the optimal isotype transition probabilities and then infer a representative B cell lineage tree for each clonotype. This proceeds until the CSR likelihood objective convergences within a tolerance defined by threshold. Multiple restarts are performed with different initial isotype transition probabilities. The initializations are defined by the stay_probs, a tuple of floats the defines an upper and lower bound on the diagonal of the isotype transition probability matrix. Given a number of restarts and stay probs,  np.linspace(lower bound, upper bound, restarts) is used to define a stay probability, i.e., the probability of  not class switching, for each restart. The remain entries in each row are either 0 if the transition violates class switching constraints, e.g., IgG -&gt; IgM, or initialized uniformly (1 - stay_prob)/# of valid transitions from start  state. </p> <p>The default mode for TRIBAL if 'refinement', during the coordinate descent step TRIBAL will find the  most parsimonious tree refinement of each tree  in the maximum parsimony forest and ancestral isotypes given the current isotype transition probabilites. In score mode, TRIBAL will not modify the input maximum parsimony trees and will only infer the ancestral isotypes using the Sankoff algorithm with a cost function given by the negative log of the isotype transition probabilities. </p> <p>If the size the of the maximum parsimony forest is very large, the parsimony forest can optionally be downsampled to a size of max_cand during each iteration of the algorithm. The best tree found so far is always included in the next iteration to ensure convergence. </p> <p>Examples:</p> <p>Here is an example of how to use the TRIBAL class::</p> <pre><code>from tribal import Tribal, clonotypes\n\n#clonotypes dictionary includes the following clonotypes\n#[\"Clonotype_1036\", \"Clonotype_1050\", \"Clonotype_10884\",\"Clonotype_1457\", \"Clonotype_755\", \"Clonotype_322\"]\n\n#the clonotype data contains the following isotypes encoded from 0 to 7\nisotypes = ['IGHM', 'IGHG3', 'IGHG1', 'IGHA1','IGHG2','IGHG4','IGHE','IGHA2']\ntr = Tribal(n_isotypes=len(isotypes), verbose=True, restarts=2, niter=15)\n\n#run in refinement mode\nshm_score, csr_likelihood, best_scores, transmat = tr.fit(clonotypes=clonotypes, mode=\"refinement\", cores=6)\n</code></pre> Source code in <code>tribal/tribal.py</code> <pre><code>class Tribal:\n    \"\"\"\n    A class to infer a B cell lineage tree for each clonotype and shared isotype transition probabilities. \n\n    Attributes\n    ----------\n    n_isotypes : int\n       the number of isotype states\n    alphabet : tuple\n        the valid alphabet for BCR sequences, defaults to  (\"A\", \"C\", \"G\", \"T\",\"N\", \"-\")\n    sankoff_cost_function : dict\n        the cost function to use for running the Sankoff algorithm during ancestral BCR sequence reconstruction.\n        the keys must be all pairs from the provided alphabet. defaults to using the standard cost\n        function (1 for a mismatch, 0 for match)\n    seed: int\n        random number seed used to randomly downsample candidate trees within each iterations when size of a parsimony forests\n        is greater than max_cand\n    max_cand: int\n        the maximum allowable size of a parsimony forest to consider within each coordinate descent iterations.\n        if the size of each maximum parsimony forest is less than max_cand then downsampling does not occur.\n     niter: int\n        the maximum number of coordinate descent iterations to perform if convergence criteria is not met, defaults to 10)\n    threshold : float\n        The tolerance for convergence of the CSR objective, defaults to 0.5\n    restarts : int\n        the number of restarts, i.e, different initialization of the isotype transition probabilities, defaults to 10\n    stay_probs : tuple\n        the lower bound and upper bound for the initialization of the probability of not class switching.\n        the initalization values of this parameter are determined by using np.linspace on this range with the\n        restarts parameter, defaults to (0.55, 0.95)\n\n    Notes\n    ----\n    TRIBAL takes as input a maximum parsimony forest (a set of trees that minimizes the SHM score for a \n    multiple sequenced alignment of the concatentated heavy and light chain (optional) variable\n    region sequences) and the encoded isotype of each sequenced B cell for k clonotypes.   See the Preprocessor class for help preparing the input data. \n    It then infers a B cell lineage tree(s) for each clonotype that minimizes the somatic hypermutation (SHM) parsimony score and then maximizes the class swtich recombination (CSR)\n    likelihood score. It also infers the optimal isotype transition probabilities that jointly maximizes the CSR likelihood.\n\n    TRIBAL uses a coordinate ascent algorithm to alternately infer the optimal isotype transition probabilities and then\n    infer a representative B cell lineage tree for each clonotype. This proceeds until the CSR likelihood objective\n    convergences within a tolerance defined by threshold. Multiple restarts are performed with different initial\n    isotype transition probabilities. The initializations are defined by the stay_probs, a tuple of floats the defines\n    an upper and lower bound on the diagonal of the isotype transition probability matrix. Given a number of restarts and stay probs, \n    np.linspace(lower bound, upper bound, restarts) is used to define a stay probability, i.e., the probability of \n    not class switching, for each restart. The remain entries in each row are either 0 if the transition violates\n    class switching constraints, e.g., IgG -&gt; IgM, or initialized uniformly (1 - stay_prob)/# of valid transitions from start \n    state. \n\n    The default mode for TRIBAL if 'refinement', during the coordinate descent step TRIBAL will find the \n    most parsimonious tree refinement of each tree  in the maximum parsimony forest and ancestral isotypes given the current isotype transition probabilites.\n    In score mode, TRIBAL will not modify the input maximum parsimony trees and will only infer the ancestral\n    isotypes using the Sankoff algorithm with a cost function given by the negative log of the isotype\n    transition probabilities. \n\n\n    If the size the of the maximum parsimony forest is very large, the parsimony forest can optionally\n    be downsampled to a size of max_cand during each iteration of the algorithm. The best tree found so far is always included\n    in the next iteration to ensure convergence. \n\n\n    Examples\n    --------\n    Here is an example of how to use the TRIBAL class::\n\n        from tribal import Tribal, clonotypes\n\n        #clonotypes dictionary includes the following clonotypes\n        #[\"Clonotype_1036\", \"Clonotype_1050\", \"Clonotype_10884\",\"Clonotype_1457\", \"Clonotype_755\", \"Clonotype_322\"]\n\n        #the clonotype data contains the following isotypes encoded from 0 to 7\n        isotypes = ['IGHM', 'IGHG3', 'IGHG1', 'IGHA1','IGHG2','IGHG4','IGHE','IGHA2']\n        tr = Tribal(n_isotypes=len(isotypes), verbose=True, restarts=2, niter=15)\n\n        #run in refinement mode\n        shm_score, csr_likelihood, best_scores, transmat = tr.fit(clonotypes=clonotypes, mode=\"refinement\", cores=6)\n\n\n    \"\"\"\n\n    def __init__(self,\n                n_isotypes = 7,\n                alphabet= (\"A\", \"C\", \"G\", \"T\",\"N\", \"-\"),\n                sankoff_cost_function = None, \n                seed= 1026, \n                max_cand=50, \n                niter=10,\n                threshold=0.5,\n                restarts=5,\n                stay_probs=(0.55,0.95), \n                verbose =False ):\n\n\n        self.n_isotypes = n_isotypes \n        self.alphabet = alphabet\n        self.sankoff_cost_function = sankoff_cost_function\n        self.seed = seed\n        self.rng = np.random.default_rng(seed)\n        self.stay_probs = stay_probs \n        self.max_cand = max_cand\n        self.threshold = threshold\n        self.niterations = niter\n        self.restarts = restarts \n        self.verbose  = verbose \n\n        if self.verbose:\n            param_str  = \"\\nTRIBAL parameters:\\n\"\n            param_str += f\"number of isotypes: {self.n_isotypes}\\n\"\n            param_str += f\"sequence alphabet: {self.alphabet}\\n\"\n            param_str += f\"maximum candidates: {self.max_cand}\\n\"\n            param_str += f\"stay probabilities: {self.stay_probs}\\n\"\n            param_str += f\"random number seed: {self.seed}\\n\"\n            param_str += f\"restarts: {self.restarts}\\n\"\n            param_str += f\"iterations: {self.niterations}\\n\"\n            param_str += f\"convergence threshold: {self.threshold}\\n\"\n            param_str += f\"verbose: {self.verbose}\\n\"\n\n            print(param_str)\n\n\n\n\n\n\n\n\n    def _intialize_candidates(self, clonotypes, best_tree_ids=None):\n        # '''\n        # randomly initialize a set of candidate trees up to max_cands \n        # for each clonotype, including the best trees found so far is dictionary\n        # is given.'''\n\n        candidates = {}\n        for c in clonotypes:\n\n            if clonotypes[c].size() &gt; self.max_cand:\n                cand = self.rng.choice(clonotypes[c].size(), self.max_cand, replace=False).tolist()\n            else:\n                cand = [i for i in range(clonotypes[c].size())]\n\n            candidates[c]= Clonotype(id = clonotypes[c].id, alignment=clonotypes[c].alignment, isotypes=clonotypes[c].isotypes)\n\n            #TODO: remove deep copy\n            for index in cand:\n                candidates[c].add(clonotypes[c][index])\n            if best_tree_ids is not None:\n                for i in best_tree_ids[c]:\n                    if i not in cand:\n                        candidates[c].add(clonotypes[c][i])\n\n        return candidates \n\n\n    def _csr_optimize(self, candidates, transmat=None, mode=None):\n\n\n            #forest returns dict with clonotype as key and LineageTreeList as value\n            all_scores = self._forest_mode(candidates, transmat)\n\n            top_scores = {}\n            total_likelihood = 0\n            for c, sl in all_scores.items():\n                best_obj, best_scores = sl.find_all_best_trees()\n                top_scores[c] = best_scores\n                total_likelihood += best_obj\n            return total_likelihood, top_scores\n\n\n    @staticmethod\n    def _check_convergence(old, new, threshold):\n        return np.abs(old -new) &lt; threshold\n\n\n    def fit(self, clonotypes, mode=\"refinement\", transmat=None, cores=1):\n        \"\"\"\n        Run TRIBAL on a dictionary of clonotypes and infer B cell lineage tree(s)\n        for each clonotype and a shared istoype transition probability matrix. \n\n        Parameters\n        ----------\n        clonotypes: dict\n            a dictionary of Clonotypes each containing a parsimony forest, isotypes and multiple sequence alignment    \n        mode: str\n            the mode for optimizing the class switch recombination (CSR) likelihood, one of [\"refinement\", \"score\"]. In\n            'refinement' mode, TRIBAL solves the most parsiminious tree refinement (MPTR) problem for each \n            candidate tree in the parsimony forest. In 'score' mode, TRIBAL  infers the ancestral isotypes using\n            the Sankoff algorithm with the weights coming from the isotype transition probabilities. \n        transmat: list\n            a optional isotype transition probabilty matrix to infer a B cell lineage\n            tree(s) for each clonotype. If not provided, the isotype transition probabilites\n            are inferred from the data. \n\n        cores: int\n            The number of cores to use (default 1)\n\n\n\n        Examples\n        --------\n        Here are examples of how to run the fit function::\n\n            from tribal import Tribal, clonotypes\n\n            #clonotypes dictionary includes the following clonotypes\n            #[\"Clonotype_1036\", \"Clonotype_1050\", \"Clonotype_10884\",\"Clonotype_1457\", \"Clonotype_755\", \"Clonotype_322\"]\n\n            isotypes = ['IGHM', 'IGHG3', 'IGHG1', 'IGHA1','IGHG2','IGHG4','IGHE','IGHA2']\n            tr = Tribal(n_isotypes=len(isotypes), verbose=True, restarts=2, niter=15)\n\n            #run in refinement mode\n            shm_score, csr_likelihood, best_scores, transmat = tr.fit(clonotypes=clonotypes, mode=\"refinement\", cores=6)\n\n            #run in scoring mode\n            shm_score, csr_likelihood, best_scores, transmat = tr.fit(clonotypes=clonotypes, mode=\"score\", cores=6)\n\n\n            #given a user-specified isotype transition probability matrix \n            from tribal import probabilites\n            shm_score, csr_likelihood, best_scores, transmat = tr.fit(clonotypes =clonotypes,\n                                                                        transmat= probabilites,\n                                                                        mode=\"refinement\", cores=6)\n\n\n\n        Returns\n        -------\n\n        shm_score: float\n            a float with the total somatic hypermutation (SHM) parsimony score for all clonotypes\n\n        csr_likelihood: float\n            a float with the total class switch recombination (CSR) likelihood score for all clonotypes\n\n        best_scores: dict \n            a dictionary of LineageTreeLists containing all optimal LineageTrees per clonotype\n\n        transmat: np.array\n            a numpy array of isotype transition probabilities\n\n\n        \"\"\"\n\n\n\n\n        self.mode = mode \n        self.nproc = cores\n        if len(clonotypes)==0:\n            raise ValueError(\"The number of clonotypes is 0. Recheck data and try again.\")\n        if self.verbose:\n            print(f\"\\nStarting TRIBAL with {len(clonotypes)} clonotypes...\")\n\n        if transmat is None:\n            if self.verbose:\n                print(\"Inferring isotype transition probabilities...\")\n            transmat = self._infer_probabilities(clonotypes)\n\n        else:\n            if self.verbose:\n                print(\"Using provided isotype transition probabilities for CSR optimization...\")\n            if transmat.shape[0] != self.n_isotypes or transmat.shape[1] != self.n_isotypes:\n                raise ValueError(\"User provided isotype transition probability matrix does not match the number of isotype states\")\n        if self.verbose:\n            print(\"\\nOptimizing the CSR Likelihood...\")\n        csr_likelihood, best_scores = self._csr_optimize(clonotypes, transmat=transmat)\n\n        if self.verbose:\n\n            print(\"Reconstructing the ancestral sequences...\")\n\n        shm_score = 0\n        for c, bst_lst in best_scores.items():\n            alignment = clonotypes[c].alignment\n            min_score = np.Inf\n            for lt in bst_lst:\n                lt.ancestral_sequence_reconstruction(alignment, self.alphabet)\n                if lt.shm_obj &lt; min_score:\n                    min_score = lt.shm_obj\n            shm_score += min_score\n\n        if self.verbose:\n            print(f\"SHM Score: {shm_score} CSR Likelihood: {csr_likelihood}\")\n            print(\"The TRIBE has spoken!\")\n        return  shm_score, csr_likelihood, best_scores, transmat\n\n\n\n\n\n    def _infer_probabilities(self, clonotypes):\n\n\n        ''' \n            jointly infer isotype transition probabilities for a set of clonotypes\n            and a B cell lineage tree that maximizes the CSR likelihood\n\n        '''\n\n        cand_tmat = []\n        cand_scores = []\n        best_trees = []\n        stay_probs = np.linspace(*self.stay_probs, self.restarts)\n        for i in range(self.restarts):\n            if self.verbose:\n                print(f\"\\nStarting restart {i}...\")\n\n            transmat =  gen_trans_mat(stay_probs[i], self.n_isotypes)\n            best_tree_ids = None \n            old_score = np.Inf\n\n            for j in range(self.niterations):\n\n                candidates = self._intialize_candidates(clonotypes, best_tree_ids)\n                current_score, all_best_scores = self._csr_optimize(candidates, transmat=transmat)\n                # all_best_scores.append(best_scores)\n\n\n                best_tree_ids =  {c: all_best_scores[c]._get_ids() for c in all_best_scores}\n\n                if self.verbose:\n                    print(f\"iteration: {j} old score: {old_score} current score: {current_score}\")\n\n                if self._check_convergence(current_score, old_score, self.threshold) or j == self.niterations -1:\n                        cand_tmat.append(transmat)\n                        cand_scores.append(current_score)\n                        best_trees.append(all_best_scores)\n                        break\n                else:\n                    old_score = current_score\n                    transmat, _ = MaxLike(self.n_isotypes).infer(all_best_scores) \n\n        min_value = min(cand_scores)\n        min_index = cand_scores.index(min_value)\n        transmat = cand_tmat[min_index]\n\n        return  transmat\n\n\n\n    #candidates should be a dict of lineage forests with clonotypes as key\n    def _forest_mode(self,  candidates, transmat):\n\n            arg_vals = []\n            for c in candidates:\n                lin_forest = candidates[c]\n                isotype_labels = lin_forest.isotypes \n                for t in lin_forest.get_forest():\n                    lt = LineageTree(clonotype=c, tree=t)\n                    arg_vals.append((transmat, lt, isotype_labels ))\n\n\n            if self.mode == \"refinement\":\n                mode_func = self._refine\n            else:\n                mode_func = self._score \n\n\n            if self.nproc &lt;= 1:\n                results = [mode_func(*args) for args in arg_vals]\n            else:\n                with Pool(self.nproc) as pool:\n                    results = pool.starmap(mode_func, arg_vals) \n\n            all_scores = {c: LineageTreeList() for c in candidates}\n            for lt in results:\n                all_scores[lt.clonotype].append(lt)\n\n            return all_scores\n\n\n\n\n    def _score(self, transmat, lt, isotype_labels):\n        lt.isotype_parsimony(isotype_labels, transmat=transmat)\n        return lt \n\n\n\n\n    def _refine(self, transmat, lt, isotype_labels):\n        lt.refinement(isotype_labels, transmat=transmat)\n        return lt\n</code></pre>"},{"location":"api/tribal/#tribal.Tribal.fit","title":"<code>fit(clonotypes, mode='refinement', transmat=None, cores=1)</code>","text":"<p>Run TRIBAL on a dictionary of clonotypes and infer B cell lineage tree(s) for each clonotype and a shared istoype transition probability matrix. </p> <p>Parameters:</p> Name Type Description Default <code>clonotypes</code> <p>a dictionary of Clonotypes each containing a parsimony forest, isotypes and multiple sequence alignment</p> required <code>mode</code> <p>the mode for optimizing the class switch recombination (CSR) likelihood, one of [\"refinement\", \"score\"]. In 'refinement' mode, TRIBAL solves the most parsiminious tree refinement (MPTR) problem for each  candidate tree in the parsimony forest. In 'score' mode, TRIBAL  infers the ancestral isotypes using the Sankoff algorithm with the weights coming from the isotype transition probabilities.</p> <code>'refinement'</code> <code>transmat</code> <p>a optional isotype transition probabilty matrix to infer a B cell lineage tree(s) for each clonotype. If not provided, the isotype transition probabilites are inferred from the data.</p> <code>None</code> <code>cores</code> <p>The number of cores to use (default 1)</p> <code>1</code> <p>Examples:</p> <p>Here are examples of how to run the fit function::</p> <pre><code>from tribal import Tribal, clonotypes\n\n#clonotypes dictionary includes the following clonotypes\n#[\"Clonotype_1036\", \"Clonotype_1050\", \"Clonotype_10884\",\"Clonotype_1457\", \"Clonotype_755\", \"Clonotype_322\"]\n\nisotypes = ['IGHM', 'IGHG3', 'IGHG1', 'IGHA1','IGHG2','IGHG4','IGHE','IGHA2']\ntr = Tribal(n_isotypes=len(isotypes), verbose=True, restarts=2, niter=15)\n\n#run in refinement mode\nshm_score, csr_likelihood, best_scores, transmat = tr.fit(clonotypes=clonotypes, mode=\"refinement\", cores=6)\n\n#run in scoring mode\nshm_score, csr_likelihood, best_scores, transmat = tr.fit(clonotypes=clonotypes, mode=\"score\", cores=6)\n\n\n#given a user-specified isotype transition probability matrix \nfrom tribal import probabilites\nshm_score, csr_likelihood, best_scores, transmat = tr.fit(clonotypes =clonotypes,\n                                                            transmat= probabilites,\n                                                            mode=\"refinement\", cores=6)\n</code></pre> <p>Returns:</p> Name Type Description <code>shm_score</code> <code>float</code> <p>a float with the total somatic hypermutation (SHM) parsimony score for all clonotypes</p> <code>csr_likelihood</code> <code>float</code> <p>a float with the total class switch recombination (CSR) likelihood score for all clonotypes</p> <code>best_scores</code> <code>dict</code> <p>a dictionary of LineageTreeLists containing all optimal LineageTrees per clonotype</p> <code>transmat</code> <code>array</code> <p>a numpy array of isotype transition probabilities</p> Source code in <code>tribal/tribal.py</code> <pre><code>def fit(self, clonotypes, mode=\"refinement\", transmat=None, cores=1):\n    \"\"\"\n    Run TRIBAL on a dictionary of clonotypes and infer B cell lineage tree(s)\n    for each clonotype and a shared istoype transition probability matrix. \n\n    Parameters\n    ----------\n    clonotypes: dict\n        a dictionary of Clonotypes each containing a parsimony forest, isotypes and multiple sequence alignment    \n    mode: str\n        the mode for optimizing the class switch recombination (CSR) likelihood, one of [\"refinement\", \"score\"]. In\n        'refinement' mode, TRIBAL solves the most parsiminious tree refinement (MPTR) problem for each \n        candidate tree in the parsimony forest. In 'score' mode, TRIBAL  infers the ancestral isotypes using\n        the Sankoff algorithm with the weights coming from the isotype transition probabilities. \n    transmat: list\n        a optional isotype transition probabilty matrix to infer a B cell lineage\n        tree(s) for each clonotype. If not provided, the isotype transition probabilites\n        are inferred from the data. \n\n    cores: int\n        The number of cores to use (default 1)\n\n\n\n    Examples\n    --------\n    Here are examples of how to run the fit function::\n\n        from tribal import Tribal, clonotypes\n\n        #clonotypes dictionary includes the following clonotypes\n        #[\"Clonotype_1036\", \"Clonotype_1050\", \"Clonotype_10884\",\"Clonotype_1457\", \"Clonotype_755\", \"Clonotype_322\"]\n\n        isotypes = ['IGHM', 'IGHG3', 'IGHG1', 'IGHA1','IGHG2','IGHG4','IGHE','IGHA2']\n        tr = Tribal(n_isotypes=len(isotypes), verbose=True, restarts=2, niter=15)\n\n        #run in refinement mode\n        shm_score, csr_likelihood, best_scores, transmat = tr.fit(clonotypes=clonotypes, mode=\"refinement\", cores=6)\n\n        #run in scoring mode\n        shm_score, csr_likelihood, best_scores, transmat = tr.fit(clonotypes=clonotypes, mode=\"score\", cores=6)\n\n\n        #given a user-specified isotype transition probability matrix \n        from tribal import probabilites\n        shm_score, csr_likelihood, best_scores, transmat = tr.fit(clonotypes =clonotypes,\n                                                                    transmat= probabilites,\n                                                                    mode=\"refinement\", cores=6)\n\n\n\n    Returns\n    -------\n\n    shm_score: float\n        a float with the total somatic hypermutation (SHM) parsimony score for all clonotypes\n\n    csr_likelihood: float\n        a float with the total class switch recombination (CSR) likelihood score for all clonotypes\n\n    best_scores: dict \n        a dictionary of LineageTreeLists containing all optimal LineageTrees per clonotype\n\n    transmat: np.array\n        a numpy array of isotype transition probabilities\n\n\n    \"\"\"\n\n\n\n\n    self.mode = mode \n    self.nproc = cores\n    if len(clonotypes)==0:\n        raise ValueError(\"The number of clonotypes is 0. Recheck data and try again.\")\n    if self.verbose:\n        print(f\"\\nStarting TRIBAL with {len(clonotypes)} clonotypes...\")\n\n    if transmat is None:\n        if self.verbose:\n            print(\"Inferring isotype transition probabilities...\")\n        transmat = self._infer_probabilities(clonotypes)\n\n    else:\n        if self.verbose:\n            print(\"Using provided isotype transition probabilities for CSR optimization...\")\n        if transmat.shape[0] != self.n_isotypes or transmat.shape[1] != self.n_isotypes:\n            raise ValueError(\"User provided isotype transition probability matrix does not match the number of isotype states\")\n    if self.verbose:\n        print(\"\\nOptimizing the CSR Likelihood...\")\n    csr_likelihood, best_scores = self._csr_optimize(clonotypes, transmat=transmat)\n\n    if self.verbose:\n\n        print(\"Reconstructing the ancestral sequences...\")\n\n    shm_score = 0\n    for c, bst_lst in best_scores.items():\n        alignment = clonotypes[c].alignment\n        min_score = np.Inf\n        for lt in bst_lst:\n            lt.ancestral_sequence_reconstruction(alignment, self.alphabet)\n            if lt.shm_obj &lt; min_score:\n                min_score = lt.shm_obj\n        shm_score += min_score\n\n    if self.verbose:\n        print(f\"SHM Score: {shm_score} CSR Likelihood: {csr_likelihood}\")\n        print(\"The TRIBE has spoken!\")\n    return  shm_score, csr_likelihood, best_scores, transmat\n</code></pre>"},{"location":"setup/cli/","title":"Command line tool (cli)","text":"<p><code>tribal</code> can also be run as a command line tool.</p> <pre><code>\u276f tribal -h\nusage: tribal [-h] {preprocess,fit} ...\n\nTribal CLI Tool\n\npositional arguments:\n  {preprocess,fit}  Sub-commands\n    preprocess      Preprocess data\n    fit             B cell lineage tree inference\n\noptional arguments:\n  -h, --help        show this help message and exit\n</code></pre>"},{"location":"setup/cli/#overview","title":"Overview","text":"<p>The cli has two sub-commands:   1. preprocess - filter the data and find a multiple sequence alignment and parsimony forsest for each clonotype.   2. fit - infer a set of optimal B cell lineage trees per clonotype an a shared isotype transition probability matrix.  </p> <p>Tip</p> <p>It is recommended to use the preprocessing tool to prepare the input data to the proper format for <code>tribal</code>.  </p>"},{"location":"setup/cli/#preprocess","title":"Preprocess","text":"<p>The preprocessing command will:     1. filter out clonotypes that are below the minimum number of cells      2. filter out cells which have v alleles that differ from the majority of the clonotype     3. perform a multiple sequence alignment (MSA) for each valid clonotype using mafft     4. infer a parsimony forest for each clonotype given the MSA using dnapars</p>"},{"location":"setup/cli/#usage","title":"Usage","text":"<pre><code>\u276f tribal preprocess -h\nusage: tribal preprocess [-h] -d DATA -r ROOTS -e ENCODING [--min-size MIN_SIZE] [--dataframe DATAFRAME] [-o OUT]\n                         [-j CORES] [--heavy] [-v]\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -d DATA, --data DATA  filename of csv file with the sequencing data\n  -r ROOTS, --roots ROOTS\n                        filename of csv file with the root sequences\n  -e ENCODING, --encoding ENCODING\n                        filename isotype encodings\n  --min-size MIN_SIZE   minimum clonotype size (default 4)\n  --dataframe DATAFRAME\n                        path to where the filtered dataframe with additional sequences and isotype encodings should be\n                        saved.\n  -o OUT, --out OUT     path to where pickled clonotype dictionary input should be saved\n  -j CORES, --cores CORES\n                        number of cores to use (default 1)\n  --heavy               only use the heavy chain and ignore the light chain\n  -v, --verbose         print additional messages\n</code></pre>"},{"location":"setup/cli/#input","title":"Input","text":"<p>The <code>--data</code>, <code>--roots</code> and <code>--encoding</code> are required arguments.  See data description for more details. The <code>--encoding</code> argument should be that path to a text file that lists the correct isotype ordering as well as the isotype labels that are present in the input data. </p> <pre><code>IGHM\nIGHG3\nIGHG1\nIGHA1\nIGHG2\nIGHG4\nIGHE\nIGHA2\n</code></pre> <p>isotype labeling</p> <p>Be sure that the labels used in the encoding file exactly match the labeling syntax in the input data. There is no standard convention for isotype labels,  e.g., IgM, M, IghM and IGHM, and therefore the convention must be provided by the user. </p> <p>#### Output</p> <p>The main output from the <code>preprocess</code> sub-command is the a pickled dictionary storing <code>Clonotype</code> objects for each retained clonotype in the data. This output file will be used as the input to the <code>fit</code> sub-command. </p> <p>#### Example</p> <p>Here is an example of how to run the preprocess sub-command.</p> <pre><code> $ tribal preprocess -d data.csv -r roots.csv -e isotypes.txt -j 4 --min-size 4 --dataframe filtered.csv -o clonotypes.pkl -v\n</code></pre>"},{"location":"setup/cli/#fit","title":"fit","text":"<p>The <code>fit</code> sub-command will infer a set of B cell lineage trees for each clonotype and a shared isotype transition probability matrix. </p>"},{"location":"setup/cli/#usage_1","title":"Usage","text":"<pre><code>tribal fit -h\nusage: tribal fit [-h] -c CLONOTYPES --n_isotypes N_ISOTYPES [--stay-prob STAY_PROB] [-t TRANSMAT] [--niter NITER]\n                  [--thresh THRESH] [-j CORES] [--max-cand MAX_CAND] [-s SEED] [--restarts RESTARTS]\n                  [--mode {score,refinement}] [--score SCORE] [--transmat-infer TRANSMAT_INFER] [--verbose]\n                  [--pickle PICKLE] [--write-results WRITE_RESULTS]\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -c CLONOTYPES, --clonotypes CLONOTYPES\n                        path to pickled clonotypes dictionary of parsimony forests, alignments, and isotypes\n  --n_isotypes N_ISOTYPES\n                        the number of isotypes states to use\n  --stay-prob STAY_PROB\n                        the lower and upper bound of not class switching, example: 0.55,0.95\n  -t TRANSMAT, --transmat TRANSMAT\n                        optional filename of isotype transition probabilities\n  --niter NITER         max number of iterations during fitting\n  --thresh THRESH       theshold for convergence in during fitting\n  -j CORES, --cores CORES\n                        number of cores to use\n  --max-cand MAX_CAND   max candidate tree size per clonotype\n  -s SEED, --seed SEED  random number seed\n  --restarts RESTARTS   number of restarts\n  --mode {score,refinement}\n                        mode for fitting B cell lineage trees, one of 'refinment' or 'score'\n  --score SCORE         filename where the objective values file should be saved\n  --transmat-infer TRANSMAT_INFER\n                        filename where the inferred transition matrix should be saved\n  --verbose             print additional messages.\n  --pickle PICKLE       path where the output dictionary of LineageTree lists should be pickled\n  --write-results WRITE_RESULTS\n                        path where all optimal solution results are saved\n</code></pre>"},{"location":"setup/cli/#input_1","title":"Input","text":"<p>The pickled dictionary of clonotypes (<code>clonotypes.pkl</code>) that is output from <code>tribal preprocess</code> will be the input to <code>tribal fit</code>.  See Clonotype for details. </p>"},{"location":"setup/cli/#example","title":"Example","text":"<p>Assuming <code>clonotypes.pkl</code> is in the working directory, here is an example of how to run  <code>tribal fit</code>. </p> <pre><code>tribal fit -c clonotypes.pkl -j 3 --transmat-infer transmat.txt --pickle lineage_trees.pkl\n--write-results results --score objective.csv\n</code></pre>"},{"location":"setup/cli/#output","title":"Output","text":"<p>There are four optional outputs from <code>tribal fit</code>:   1.  <code>--transmat-infer</code>: the inferred isotype transition probability matrix.   2.  <code>--pickle</code> : a dictionary with clonotype id as key and value is a LineageTreeList containing the optimal lineage trees for each clonotype.   3.  <code>--score</code> : a  csv file containing the SHM parsimony scores and CSR likelihood.   4.  <code>--write-results</code> : a directory where the lineage trees files will be saved including:     + a fasta file containing the inferred BCR sequences,     + a csv file containing the inferred isotypes,     + a text file containing the  edge list of the lineage tree,     + a png file containing a visualization of the lineage tree.    </p>"},{"location":"setup/data/","title":"Input Data","text":"<p><code>tribal</code> requires the input data to be first clustered into clonotypes, i.e., groups of cells that descend from the same naive B cell receptor.  We recommend Dandelion to assist with this preprocessing step. </p> <p><code>tribal</code> requires two input files for preprocessing. The  single-cell RNA sequencing data and the germline root sequences. </p>"},{"location":"setup/data/#sequencing-data","title":"Sequencing data","text":"<p>Sequencing data should be provided in a csv file with the following columns:   </p> Column Name Type Description Required cellid str or int unqiue id or barcode of the sequnced B cell True clonotype str unique clonotype id to which that cell belongs True heavy_chain_isotype str the isotype of the constant region of the heavy chain True heavy_chain_seq str the variable region sequence of the heavy chain True heavy_chain_allele str the v allele of the heavy chain True heavy_chain_isotype str the isotype of the constant region of the heavy chain True light_chain_seq str the variable region sequence of the light chain False light_chain_allele str the v allele of the light chain False, if light_chain_seq not provided"},{"location":"setup/data/#germline-clonotype-roots","title":"Germline clonotype roots","text":"<p>Additionally, the germline root sequences by clonotype should be provided in a csv file containing the heavy chain sequence and optionally, the light chain sequence. </p> Column Name Type Description Required clonotype str unique clonotype id of the germline root (naive BCR) True heavy_chain_root str the heavy chain variable region germline root sequence True light_chain_root str the light chain variable region germline root sequence False <p>Note</p> <p>All light chain columns may be omitted if the <code>use_light_chain</code> argument in <code>preprocess</code> is <code>False</code>.  In other words, <code>tribal</code> may be used with only the heavy chain BCR sequences.</p>"},{"location":"setup/install/","title":"Installation","text":"<p><code>tribal</code> can be installed via <code>bioconda</code> (recommended) or <code>github</code> and can be run as a python package or via the command line. </p>"},{"location":"setup/install/#dependencies","title":"Dependencies","text":"<p><code>tribal</code> has the following dependencies: <pre><code>    python&gt;=3.9\n    numpy&gt;=1.26.3\n    networkx&gt;=3.1\n    ete3&gt;=3.1.2\n    glpk&gt;=5.0\n    pyomo&gt;=6.7.3\n    pygraphviz&gt;=1.10\n    pandas&gt;=2.1.1\n    biopython&gt;=1.81\n    mafft&gt;=7.526\n    phylip&gt;=3.697 (included with package)\n</code></pre></p> <p><code>tribal</code> can be installed from Github or from bioconda.  We recommend installing from bioconda.</p>"},{"location":"setup/install/#installing-from-bioconda","title":"Installing from bioconda","text":"<pre><code>conda create -n tribal -c bioconda tribal\nconda activate tribal\n</code></pre>"},{"location":"setup/install/#installing-from-github","title":"Installing from GitHub","text":"<pre><code>git clone https://github.com/elkebir-group/TRIBAL.git\ncd TRIBAL\n</code></pre> <p>Dependencies can be installed using a package mangager such as <code>conda</code>, <code>mamba</code> or <code>micromamba</code>, using the included <code>tribal.yml</code> file.</p> <pre><code>conda create -f tribal.yml \n</code></pre> <p>To build and install <code>tribal</code> into this environment, follow the instructions below.</p> <pre><code>conda activate tribal\npip install hatchling\nhatchling build\npip install dist/tribal-0.1.0-py3-none-any.whl\n</code></pre>"},{"location":"setup/install/#verifying-installation","title":"Verifying installation","text":"<p><code>tribal</code> can be imported as a package or run via a  command line interface.  </p> <p>To verify the package can be imported,  run the following in the terminal.</p> <pre><code>python -c \"import tribal\"\n</code></pre> <p>See Package Overivew for more detailed usage intstructions. </p> <p>To verify the CLI tool was properly installed, run the following in the terminal. </p> <pre><code>tribal --help\n</code></pre> <p>See Command Line Interface for more detailed usage intstructions.</p>"},{"location":"setup/package/","title":"Package overview","text":"<p>The <code>tribal</code> package can be imported as a package into a python script or jupyter notebookd or it can be used as a command line tool. </p> <p>The following functions and classes are accessible via the <code>tribal</code> package:  </p> Name Description Type preprocess preprocess the input data to the correct format for tribal by finding a multiple sequence aligment and parsimony forest for each clonotype function BaseTree a class to model the lineage tree topology class Clonotype a dataclass to structure the input data for <code>tribal</code> class Tribal the main class to run the <code>tribal</code> algorithm and fit the input data class LineageTree a class to model an inferred B cell lineage tree class LineageTreeList an extensions of class list to contain a list of B cell lineage trees class <p>The API provides additional details on each of these items. </p>"},{"location":"setup/package/#example-data","title":"Example data","text":"<p>In addition to the above functions and class, the following example data can be imported to help users better understand the data formatting and package use. </p> Name Description Type df input sequencing data <code>pandas.DataFrame</code> roots input germline roots for sequencing data <code>pandas.DataFrame</code> probabilities example isotype transition probability matrix <code>numpy.ndarray</code> clonotypes dictionary of Clonotype objects <code>dict</code> lineage_tree an example inferred B cell lineage tree LineageTree lineage_tree_list an example inferred B cell lineage tree list LineageTreeList <p>See Data for more details on the input format for the data. </p> <p>Load and view the example input data:</p> <pre><code>from tribal import df, roots\n\nprint(df.head())\nprint(roots.head())\n</code></pre> <p>Load and view the example output data from <code>preprocess</code>:</p> <pre><code>from tribal import clonotypes\nfor key, clonotype in clonptypes:\n    print(key)\n    print(clonotype)\n</code></pre> <p>Load and view the example output data from the <code>tribal</code> algorithm:</p> <pre><code>from tribal import probabilities, lineage_tree, lineage_tree_list\nprint(probabilities)\nprint(lineage_tree)\nprint(lineage_tree_list)\n</code></pre>"},{"location":"setup/package/#using-the-package","title":"Using the package","text":"<p>Here is a brief walkthrough of how to utilize the functionality of the <code>tribal</code> package. First, load the package:</p> <pre><code>import tribal\n</code></pre> <p>or, alternatively load specific functions, classes or example data.</p> <pre><code>from tribal import preprocess, df, roots\n</code></pre>"},{"location":"setup/package/#preprocessing","title":"Preprocessing","text":"<p>The preprocess function will:     -  filter out clonotypes that are below the minimum number of cells .     -  filter out cells which have v alleles that differ from the majority of the clonotype     -  perform a multiple sequence alignment (MSA) for each valid clonotype using mafft     -  infer a parsimony forest for each clonotype given the MSA using dnapars </p> <p>See preprocess for more details. </p> <pre><code>    from tribal import preprocess, df, roots\n    isotypes = ['IGHM', 'IGHG3', 'IGHG1', 'IGHA1','IGHG2','IGHG4','IGHE','IGHA2']\n    clonotypes, df_filt = preprocess(df, roots,isotypes=isotypes, \n                                    min_size=4, use_light_chain=True, \n                                    cores=3, verbose=True)\n</code></pre> <p>The output dictionary <code>clonotypes</code> is the formatted input to <code>tribal</code>.  To view the formatted example data without running the preprocessing step, run the following.</p> <pre><code>from tribal import clonotypes\nfor key, clonotype in clonotypes:\n    print(clonotype)\n</code></pre>"},{"location":"setup/package/#running-tribal","title":"Running TRIBAL","text":"<p>Tribal takes the dictionary of Clonotype objects as input and can be run in two modes.  1. <code>refinement</code> (recommended) : the full algorithm where the CSR likelihood is optimized by solving the most parsimonious tree refinement problem. 2. <code>score</code> : the input parsimony lineage trees are not refined and isotypes of the internal nodes are inferred using weighted parsimony via the Sankoff algorithm, with the isotype transition probabilities as weights.   </p> <p><pre><code>from tribal import Tribal, clonotypes\n\n#the clonotype data contains the following isotypes encoded from 0 to 7\nisotypes = ['IGHM', 'IGHG3', 'IGHG1', 'IGHA1','IGHG2','IGHG4','IGHE','IGHA2']\ntr = Tribal(n_isotypes=len(isotypes), restarts=2, niter=15, verbose=True)\n\n#run in refinement mode (recommended)\nshm_score, csr_likelihood, best_trees, probabilities = tr.fit(clonotypes=clonotypes, \n                                                                mode=\"refinement\", cores=3)\n\n#run in score mode to infer isotypes using weighted parsimony (Sankoff algorithm) w/o tree refinement\nshm_score, csr_likelihood, best_trees, probabilities = tr.fit(clonotypes=clonotypes, \n                                                                mode=\"score\", cores=3)\n</code></pre> <code>shm_score</code> and <code>csr_likelihood</code> are floats representing the corresponding SHM or CSR objective values. </p> <p><code>probabilities</code> is a numpy array of shape <code>(n_isotypes, n_isotypes)</code> containing the inferred isotype transition probabilites. </p> <p><code>best_trees</code> is a dictionary with clonotype id as key and the value containing a LineageTreeList with all inferred optimal B cell lineage trees for a given clonotype. </p> <p>Additionally, <code>Tribal</code> can be <code>fit</code> with a user-provided isotype transition probability matrix:</p> <pre><code>from tribal import Tribal, clonotypes, probabilities\n\n#the clonotype data contains the following isotypes encoded from 0 to 7\nisotypes = ['IGHM', 'IGHG3', 'IGHG1', 'IGHA1','IGHG2','IGHG4','IGHE','IGHA2']\ntr = Tribal(n_isotypes=len(isotypes), restarts=2, niter=15, verbose=True)\n\n#specifying the transmat argument will skip the step of inferring isotype transition probabilites\nshm_score, csr_likelihood, best_trees, probabilities = tr.fit(clonotypes=clonotypes,\n                                                                mode=\"refinement\", transmat=probabilites, \n                                                                cores=3)\n</code></pre>"},{"location":"setup/package/#exploring-and-visualizing-the-inferred-b-cell-lineage-trees","title":"Exploring and visualizing the inferred B cell lineage trees","text":"<p><code>tribal fit</code> returns a list of all optimal B cell lineage trees for each clonotype.  Specifically, in the above examples <code>best_trees</code> is a dictionary, with clonotype as key, of LineageTreeLists. </p> <p>A B cell lineage tree for tribal is a rooted tree with nodes labeled by BCR sequences (concentated heavy and optional light chains) and by isotypes. The LineageTree class also holds the current  SHM parsimony score (<code>shm_obj</code>) and CSR likelihood (<code>csr_obj</code>). </p> <p>A <code>LineageTree</code> can be visualized as a <code>png</code> or <code>pdf</code> via the draw function.  Nodes are colored by the isotype via the default <code>color_encoding</code>. </p> <pre><code> color_encoding =  {\n                -1: \"#FFFFFF\",\n                0 : \"#808080\",\n                1 : \"#FFEDA0\",\n                2 : \"#FD8D3C\",\n                3 : \"#E31A1C\",\n                4 : \"#800026\",\n                5 : \"#6A51A3\",\n                6 : \"#74C476\",\n                7 : \"mediumseagreen\",\n                8 : \"darkgoldenrod\",\n                9 : \"thistle1\"\n        }\n</code></pre> <p><code>show_legend=True</code> provides a legend on the visualization depicting the color encoding. if <code>isotype_encoding</code> is provided in the form of a list, i.e., <code>['IGHM', 'IGHG3', 'IGHG1', 'IGHA1','IGHG2','IGHG4','IGHE','IGHA2']</code> then the legend will be utilize the isotype labeling. Otherwise, the encoding is used. </p> <p>The <code>show_labels</code> argument can be used to toggle on and off the labeling of the sequences. </p> <pre><code>from tribal import lineage_tree\nprint(lineage_tree)\n\nisotypes = ['IGHM', 'IGHG3', 'IGHG1', 'IGHA1','IGHG2','IGHG4','IGHE','IGHA2']\n#output visualization as a png with sequence labels included.\nlineage_tree.draw(fname=\"example_tree.png\", \n                isotype_encoding=isotypes,\n                show_legend=True,\n                show_labels=True,\n                color_encoding=None,\n                )\n\n#output visualization as a pdf with sequence labels excluded.\nlineage_tree.draw(fname=\"example_tree.pdf\", \n                isotype_encoding=isotypes,\n                show_legend=True,\n                show_labels=False,\n                color_encoding=None,\n                )\n</code></pre> <p>The output file can also be saved as dot file instead of a png for pdf. Use the <code>dot</code> argument to indicate that file should be written as a dot file.</p> <pre><code>from tribal import lineage_tree\n\n\nisotypes = ['IGHM', 'IGHG3', 'IGHG1', 'IGHA1','IGHG2','IGHG4','IGHE','IGHA2']\n#output visualization as a png with sequence labels included.\nlineage_tree.draw(fname=\"example_tree.dot\", \n                isotype_encoding=isotypes,\n                show_legend=True,\n                show_labels=True,\n                color_encoding=None,\n                dot = True\n                )\n</code></pre> <p>Use the write function the lineage tree data to files including: 1. The sequences as a FASTA file 2. The isotypes as a csv file 3. The tree as a png 4. The edge list of the lineage tree</p> <pre><code>from tribal import lineage_tree\nlineage_tree.write(\"lineage_tree_files\")\n</code></pre> <p>You can also pass the corresponding <code>Clonotype</code> object to utilize the stored isotype encoding for the clonotype.</p> <pre><code>from tribal import lineage_tree, clonotypes\nclonotpye = clonotypes[lineage_tree.clonotype]\nlineage_tree.write(\"lineage_tree_files\", clonotype=clonotype)\n\n#an additional label to append to the file names can be optional provided\nlineage_tree.write(\"lineage_tree_files\", clonotype=clonotype,   tree_label=\"best\")\n</code></pre> <p>The LineageTree class also provides the ability to perform preorder, postorder traversals of the nodes or to iterate through all the nodes or edges in the lineage tree.</p> <pre><code>from tribal import lineage_tree\nisotypes = ['IGHM', 'IGHG3', 'IGHG1', 'IGHA1','IGHG2','IGHG4','IGHE','IGHA2']\n#preorder traversal\nfor n in lineage_tree.preorder_traversal():\n    print(f\"Node {n}\\nBCR Sequence:{lineage_tree.sequences[n]}\\nIsotype:{lineage_tree.isotypes[isotypes[n]]}\")\n\n#postoder traversal\nfor n in lineage_tree.postorder_traversal():\n    print(f\"{n}\\nBCR Sequence{lineage_tree.sequences[n]}\\nIsotype{lineage_tree.isotypes[isotypes[n]]}\")\n\n#iterate over nodes\nfor n in lineage_tree.nodes():\n    print(f\"{n}\\nBCR Sequence{lineage_tree.sequences[n]}\\nIsotype{lineage_tree.isotypes[isotypes[n]]}\")\n\n#iterate over edges\nfor u,v in lineage_tree.edges():\n    print(f\"{u}-&gt;{v}\")\n</code></pre> <p>Lastly, you can query the parent, children, leaf status, root status of a specified node:</p> <pre><code>from tribal import lineage_tree\nisotypes = ['IGHM', 'IGHG3', 'IGHG1', 'IGHA1','IGHG2','IGHG4','IGHE','IGHA2']\n\n#preorder traversal\nnodes = lineage_tree.nodes()\nn = nodes[0]\n\n#get parent of node n\nprint(lineage_tree.parent(n))\n\n#get children of node n\nprint(lineage_tree.children(n))\n\n#check if node n is a leaf\nprint(lineage_tree.is_leaf(n))\n\n#check if node n is the root\nprint(lineage_tree.is_root(n))\n\n#get the leafset \nprint(lineage_tree.get_leafs())\n\n#get a dictionary containing the parent of every node\nprint(lineage_tree.get_parents())\n</code></pre>"},{"location":"setup/package/#functionality-of-a-lineagetreelist","title":"Functionality of a LineageTreeList","text":"<p>The LineageTreeList is an extension of list, which provides additional functionality for organizing a list of LineageTree objects. </p> <pre><code>from tribal import lineage_tree, LineageTreeList\n\nlt_list = LineageTreeList()\nlt_list.append(lineage_tree)\nprint(lt_list)\n</code></pre> <p>The LineageTreeList class provides functionality to find the optimal or all optimal LineageTree  in the list or randomly sample one. </p> <pre><code>from tribal import lineage_tree_list\n\nprint(len(lineage_tree_list))\n#if there are multiple optimal solutions, the first in the list is returned\nbest_score, best_tree = lineage_tree_list.find_best_tree()\nprint(best_score)\nprint(best_tree)\n\nbest_score, all_best  = lineage_tree_list.find_all_best_trees()\nprint(best_score)\n\nrandom_score, random_tree = lineage_tree_list.sample_best_tree(seed=10)\nprint(random_tree)\n</code></pre> <p>In addition, the class provides a wrapper to the <code>write</code> function in LineageTree to write all the lineage tree files to disk.</p> <pre><code>from tribal import lineage_tree_list\n\n\nlineage_tree_list.write_all(outpath=\"all_trees\")\n\n#or to utilize isotype labels for the isotype files instead of numerical encoding\nisotypes = ['IGHM', 'IGHG3', 'IGHG1', 'IGHA1','IGHG2','IGHG4','IGHE','IGHA2']\n\nlineage_tree_list.write_all(outpath=\"all_trees\", isotype_encoding=isotypes)\n</code></pre> <p>Lastly, a CSV file with the objective values of each LineageTree in the list can be written.</p> <pre><code>from tribal import lineage_tree_list\nisotypes = ['IGHM', 'IGHG3', 'IGHG1', 'IGHA1','IGHG2','IGHG4','IGHE','IGHA2']\nlineage_tree_list.write(\"objectives.csv\", isotype_encoding=isotypes)\n</code></pre>"}]}